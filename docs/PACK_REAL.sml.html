<html><head><head><link rel='stylesheet' href='jslib/jquery-ui.css'></link><script src='jslib/jquery-1.9.1.js'></script><script src='jslib/jquery-ui.js'></script><script src='generated_tags.js'></script><link rel='stylesheet' href='jslib/style.css'></link><script>function copyText(text) { console.log('hi'); try { navigator.clipboard.writeText(text); console.log('Text copied!'); } catch (err) { console.error('error copying text', err); } }</script><script>$(function() {   $( '#tags' ).autocomplete({    source: availableTags,    select: function(event,ui){ window.location = ui.item.value; }  });});</script></head></head><body><table width='100%'><tr><td><a href="https://elsman.com/mlkit/"><img height="30pt" src="mlkit.png"/></a></td><td>Library Documentation</td><td align='center'><a href='str_idx.html'>Structures</a></td><td align='center'><a href='sig_idx.html'>Signatures</a></td><td align='center'><a href='id_idx.html'>Identifiers</a></td><td align='center'><a href='pkg_idx.html'>Packages</a></td><td align='right'><a href='about.html'>About</a></td></tr></table><p style='width:100%'><input id='tags' placeholder='Search' style='width:100%; margin-right:20px;'></input></p><h4>Signature <code>PACK_REAL</code> <tt><i>(basis)</i></tt></h4><p> Operations for packing and unpacking real values. </p><hr /><pre><b>structure PackRealLittle : PACK_REAL <i>(basis)</i>
</b><b>structure PackRealBig : PACK_REAL <i>(basis)</i>
</b></pre><hr /><pre><b>signature</b> PACK_REAL =
  <b>sig</b>
    <b>type</b> real
    <b>val</b> <a href='#bytesPerElem'>bytesPerElem</a> : int
    <b>val</b> <a href='#isBigEndian'>isBigEndian</a> : bool
    <b>val</b> <a href='#toBytes'>toBytes</a>   : real -> <a href='MONO_VECTOR.sml.html'>Word8Vector</a>.vector
    <b>val</b> <a href='#fromBytes'>fromBytes</a> : <a href='MONO_VECTOR.sml.html'>Word8Vector</a>.vector -> real
    <b>val</b> <a href='#subVec'>subVec</a> : <a href='MONO_VECTOR.sml.html'>Word8Vector</a>.vector * int -> real
    <b>val</b> <a href='#subArr'>subArr</a> : <a href='MONO_ARRAY.sml.html'>Word8Array</a>.array * int -> real
    <b>val</b> <a href='#update'>update</a> : <a href='MONO_ARRAY.sml.html'>Word8Array</a>.array * int * real -> unit
  <b>end</b>
</pre><hr /><dl><dt><b>[<tt><a name='bytesPerElem'>bytesPerElem</a></tt>]</b></dt> <dd>The number of bytes per element, sufficient to store a
value of type real.
</dd><br /><dt><b>[<tt><a name='isBigEndian'>isBigEndian</a></tt>]</b></dt> <dd>is true if the structure implements a big-endian view of the data.
</dd><br /><dt><b>[<tt><a name='toBytes'>toBytes r</a></tt>]</b></dt><dt><b>[<tt><a name='fromBytes'>fromBytes v</a></tt>]</b></dt> <dd>These functions pack and unpack floating-point values
into and out of Word8Vector.vector values. The function fromBytes
raises the Subscript exception if the argument vector does not have
length at least bytesPerElem; otherwise the first bytesPerElem bytes
are used.
</dd><br /><dt><b>[<tt><a name='subVec'>subVec (seq, i)</a></tt>]</b></dt><dt><b>[<tt><a name='subArr'>subArr (seq, i)</a></tt>]</b></dt> <dd>These functions extract the subsequence
<pre>
    seq[bytesPerElem*i..bytesPerElem*(i+1)-1]
</pre>

of the aggregate seq and convert it into a real value according to the
endianness of the structure. They raise the Subscript exception if i &lt;
0 or if Word8Array.length seq &lt; bytesPerElem * (i + 1).
</dd><br /><dt><b>[<tt><a name='update'>update (arr, i, r)</a></tt>]</b></dt> <dd>stores r into the bytes bytesPerElem*i through
bytesPerElem*(i+1)-1 of the array arr, according to the structure's
endianness. It raises the Subscript exception if i &lt; 0 or if
Word8Array.length arr &lt; bytesPerElem * (i + 1).
</dd><br /></dl><hr /><i>Generated by <a href='http://github.com/melsman/sigdoc'>SigDoc</a></i></body></html>