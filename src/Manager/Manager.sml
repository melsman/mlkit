
functor Manager(structure ManagerObjects : MANAGER_OBJECTS
                structure IntModules : INT_MODULES
                sharing type ManagerObjects.IntBasis = IntModules.IntBasis
                sharing type ManagerObjects.modcode = IntModules.modcode)
    : MANAGER =
  struct
    structure PP = PrettyPrint
    structure MO = ManagerObjects
    structure Basis = MO.Basis
    structure ModCode = MO.ModCode
    structure IntBasis = MO.IntBasis
    structure ElabBasis = ModuleEnvironments.B
    structure ErrorCode = ParseElab.ErrorCode
    structure H = Polyhash

    fun testout (s: string):unit = TextIO.output(TextIO.stdOut, s)
    fun testouttree (t:PP.StringTree) = PP.outputTree(testout,t,80)

    type absprjid = ModuleEnvironments.absprjid
    type InfixBasis = ManagerObjects.InfixBasis
    type ElabBasis = ManagerObjects.ElabBasis
    type IntBasis = ManagerObjects.IntBasis
    type opaq_env = ManagerObjects.opaq_env

    fun die s = Crash.impossible ("Manager." ^ s)

    val op ## = OS.Path.concat infix ##

    val region_profiling = Flags.is_on0 "region_profiling"

    val print_export_bases =
        Flags.add_bool_entry
            {long="print_export_bases", short=SOME "Peb", neg=false,
             item=ref false,
             menu=["Printing of environments", "print export bases"],
             desc="Controls printing of export bases."}

    val print_closed_export_bases =
        Flags.add_bool_entry
            {long="print_closed_export_bases", short=SOME "Pceb", neg=false,
             item=ref false,
             menu=["Printing of environments", "print closed export bases"],
             desc="Controls printing of closed export bases."}

    val run_file =
        Flags.add_string_entry
            {long="output", short=SOME "o", item=ref "run",
             menu=["File", "output file name"],
             desc="The name of the executable file generated by\n\
                  \the Kit."}

    val link_code =
        Flags.add_stringlist_entry
            {long="link_code", short=NONE, item=ref nil,
             menu=["File", "link files"],
             desc="Link-files to be linked together to form an\n\
                  \executable."}

    val load_basis_files =
        Flags.add_stringlist_entry
            {long="load_basis_files", short=SOME "load", item=ref nil,
             menu=["File", "Basis files to load before compilation"],
             desc="Basis files to be loaded before compilation\n\
                  \proper."}

    val _ = Flags.add_stringlist_entry
      {long="mlb_path_maps", short=SOME"mlb-path-map", item=ref nil,
       menu=["File", "ML Basis path map files to use"],
       desc="ML Basis path map files to be used."}

    val namebase =
        Flags.add_string_entry
            {long="namebase", short=NONE, item=ref "dummyBase",
             menu=["File", "Name base"],
             desc="Name base to enforce unique names when compiling\n\
                  \mlb-files."}

    val print_post_elab_ast =
        Flags.add_bool_entry
            {long="print_post_elab_ast", short=SOME "Ppeast", neg=false,
             item=ref false,
             menu=["Printing of intermediate forms", "print ast after elaboation"],
             desc="Print ast after elaboration."}

    val inline_functors =
        Flags.add_bool_entry
            {long="inline_functors", short=NONE, neg=false,
             item=ref false,
             menu=["General Control", "inline functors"],
             desc="Inline functors during static interpretation instead of\n\
                  \generating separate target code blocks for functor bodies\n\
                  \and arguments. With the flag enabled, performance may\n\
                  \increase with the cost of larger (re)compilation times.\n\
                  \The flag may be controlled in mlb-files using mlb-\n\
                  \annotations."}

    exception PARSE_ELAB_ERROR = MO.PARSE_ELAB_ERROR
    fun error a = MO.error a
    val quot = MO.quot

    (* -----------------------------------------
     * Unit names, file names and directories
     * ----------------------------------------- *)

    type filename = MO.filename       (* At some point we should use *)
                                      (* abstract types for these things *)
                                      (* so that we correctly distinguish *)
                                      (* unit names and file names. *)

    fun unitname_to_logfile unitname = unitname ^ ".log"
    fun unitname_to_sourcefile unitname = MO.mk_filename unitname (*mads ^ ".sml"*)
    fun filename_to_unitname (f:filename) : string = MO.filename_to_string f

    val log_to_file = Flags.lookup_flag_entry "log_to_file"

    fun modTime (f:string) : Time.time option =
        SOME (OS.FileSys.modTime f)
        handle _ => NONE

    (* ----------------------------------------------------
     * log_init  gives you back a function for cleaning up
     * ---------------------------------------------------- *)

    fun log_init unitname =
      let val old_log_stream = !Flags.log
          val log_file = unitname_to_logfile unitname
          val source_file = unitname_to_sourcefile unitname
      in if !log_to_file then
           let val log_stream = TextIO.openOut log_file
                     handle IO.Io {name=msg,...} =>
                       die ("Cannot open log file\n\
                            \(non-exsisting directory or write-\
                            \protected existing log file?)\n" ^ msg)
               fun log_init() = (Flags.log := log_stream;
                                 TextIO.output (log_stream, "\n\n********** "
                                         ^ MO.filename_to_string source_file ^ " *************\n\n"))
               fun log_cleanup() = (Flags.log := old_log_stream; TextIO.closeOut log_stream;
                                    TextIO.output (TextIO.stdOut, "[wrote log file:\t" ^ log_file ^ "]\n"))
           in log_init();
              log_cleanup
           end
         else
           let val log_stream = TextIO.stdOut
               fun log_init() = Flags.log := log_stream
               fun log_cleanup() = Flags.log := old_log_stream
           in log_init();
              log_cleanup
           end
      end

    fun log (s:string) : unit = TextIO.output (!Flags.log, s)
    fun pr_st (st) : unit = PP.outputTree (print, st, 120)
    fun chat s = if !Flags.chat then log (s ^ "\n") else ()
    fun chatf f = if !Flags.chat then log (f() ^ "\n") else ()

    (* -------------------------------------------
     * Debugging and reporting
     * ------------------------------------------- *)

    fun print_error_report report = Report.print' report (!Flags.log)
    fun print_result_report report = (Report.print' report (!Flags.log);
                                      Flags.report_warnings ())

    type Basis = MO.Basis
    type modcode = MO.modcode

    structure PickleBases =
    struct
    local (* Pickling *)

        fun readFile f : string =
            let val is = BinIO.openIn f
            in let val v = BinIO.inputAll is
                   val s = Byte.bytesToString v
               in BinIO.closeIn is; s
               end handle ? => (BinIO.closeIn is; raise ?)
            end

        fun sizeToStr sz =
            if sz < 10000 then Int.toString sz ^ " bytes"
            else if sz < 10000000 then Int.toString (sz div 1024) ^ "Kb (" ^ Int.toString sz ^ " bytes)"
                 else Int.toString ((sz div 1024) div 1024) ^ "Mb (" ^ Int.toString sz ^ " bytes)"

        type timer = (string * Timer.cpu_timer * Timer.real_timer)

        fun timerStart (s:string) : timer =
            (s,Timer.startCPUTimer(),Timer.startRealTimer())

        fun timerReport ((s,cputimer,realtimer):timer) : unit =
            let fun showTimerResult (s,{usr,sys},real) =
                print ("\nTiming " ^ s ^ ":"
                       ^ "\n  usr  = " ^ Time.toString usr
                       ^ "\n  sys  = " ^ Time.toString sys
                       ^ "\n  real = " ^ Time.toString real
                       ^ "\n")
            in showTimerResult (s, Timer.checkCPUTimer cputimer,
                                Timer.checkRealTimer realtimer)
            end handle _ => print "\ntimerReport.Uncaught exception\n"

        fun targetFromOutput file ext =
            file ^ "." ^ ext

        fun writeTextFile file s =
            let val os = TextIO.openOut file
                val _ = chatf (fn() => " [Writing file " ^ file ^ "...]")
            in (  TextIO.output(os,s)
                ; TextIO.closeOut os
                ) handle X => (TextIO.closeOut os; raise X)
            end

        fun isFileContentStringBIN f s =
            let val is = BinIO.openIn f
            in ((Byte.bytesToString (BinIO.inputAll is) = s)
                handle _ => (BinIO.closeIn is; false))
               before BinIO.closeIn is
            end handle _ => false

        fun writePickle file pickleString =
            let val os = BinIO.openOut file
                  val _ = chatf (fn() => " [Writing pickle to file " ^ file ^ "...]")
              in (  BinIO.output(os,Byte.stringToBytes pickleString)
                  ; BinIO.closeOut os
                 ) handle X => (BinIO.closeOut os; raise X)
              end

        fun 'a doPickleGen0 (punit:string) (pu_obj: 'a Pickle.pu) (ext: string) (obj:'a) : string =
            let val _ = chatf (fn() => " [Begin pickling " ^ ext ^ "-result for " ^ punit ^ "...]")
                (*  val timer = timerStart "Pickler" *)
                val res = Pickle.pickle pu_obj obj
                (* val _ = timerReport timer *)
                val _ = chatf (fn() => " [End pickling " ^ ext ^ " (sz = " ^ sizeToStr (size res) ^ ")]")
            in res
            end

        fun 'a doPickleGen (smlfile:string) (ofile:string) (pu_obj: 'a Pickle.pu) (ext: string) (obj:'a) =
            let val res = doPickleGen0 smlfile pu_obj ext obj
                val file = targetFromOutput ofile ext
            in writePickle file res
            end

        fun unpickleGen ofile pu ext : 'a option =    (* MEMO: perhaps use hashconsing *)
            let val s = readFile (targetFromOutput ofile ext)
                val res = Pickle.unpickle pu s
            in SOME res
            end handle _ => NONE

        val Hexn = Fail "Manager.Polyhash.failure"

        fun renameN H N i =
            let fun nextAvailableKey(H,i) =
                    case H.peek H i of
                        SOME _ => nextAvailableKey(H,i+1)
                      | NONE => i
            in foldl (fn (n,i) =>
                         let val i = nextAvailableKey(H,i)
                         in Name.assignKey(n,i)
                          ; i + 1
                         end) i N
            end

        type name = Name.name

        fun app2 f l1 l2 = (List.app f l1 ; List.app f l2)
        fun 'a matchGen (match:'a*'a->'a) ((N,B:'a),(N0,B0:'a)) : name list * 'a =
            let val _ = app2 Name.mark_gen N N0
                val B = match(B,B0)
                val _ = app2 Name.unmark_gen N N0
            in (N,B)
            end

        val pu_names = Pickle.listGen Name.pu
        val pu_NB0 = Pickle.pairGen(pu_names,Basis.pu_Basis0)
        val pu_NB1 = Pickle.pairGen(pu_names,Basis.pu_Basis1)

        (* Before we determine not to write to disk, we need to check
         * that *both* NB0's and NB1's are identical. *)

        (* We need to read in both NB0_0 and NB1_0 from disk in order
         * to choose fresh names for NB0_1 and NB1_1 *)

        fun rename (N,N') (N0,N1) =
            let (* How do we make sure that (N of NB0) U (N of NB1) are disjoint from
                 * (N U N') ? We do this by an explicit renaming of
                 * (N of NB0) to N0' and (N of NB1) to N1 such that (N0 U N1)(B0,B1,m)
                 * = (N0' U N1')(B0',B1',m') and
                 * N0 \cap N1 = \emptyset and (N0 U N1) \cap (N U N') = \emptyset.
                 *   Idea: insert keys of members of N and N' in a hashSet;
                 * for each member n in (N of NB0 U N of NB1), starting with 1,
                 * pick a new key k not in hashSet and reset key(n)
                 * to k. This implements a capture free renaming of
                 * (N)(B,m) because basenames((N)(B,m)) \cap basenames(N)
                 * = \emptyset. This last assumption holds only because
                 * different basenames are used for eb and eb1 export
                 * bases. *)
              val H : (int,unit) H.hash_table =
                  H.mkTable (fn x => x, op =) (31, Hexn)
              val _ = app2 (fn n => H.insert H (#1(Name.key n),())) N N'
              val _ = renameN H N1 (renameN H N0 1)
            in ()
            end

        fun eqNB eqB ((N,B),(N',B')) =
            length N = length N' andalso eqB (B,B')

        datatype when_to_pickle = NOT_STRING_EQUAL | NOT_ALPHA_EQUAL | ALWAYS

        val whenToPickle : when_to_pickle = NOT_STRING_EQUAL

    in

    fun pickleNB (smlfile:string) (ofile:string) (NB0,NB1) : unit =
        let val (ext0,ext1) = ("eb","eb1")
            fun pickleBoth (NB0,NB1) =
                (doPickleGen smlfile ofile pu_NB0 ext0 NB0;
                 doPickleGen smlfile ofile pu_NB1 ext1 NB1)
        in case whenToPickle of
               ALWAYS => pickleBoth(NB0,NB1)
             | NOT_STRING_EQUAL =>
               let val f0 = targetFromOutput ofile ext0
                   val f1 = targetFromOutput ofile ext1
                   val p0 = doPickleGen0 smlfile pu_NB0 ext0 NB0
                   val p1 = doPickleGen0 smlfile pu_NB1 ext1 NB1
               in if (isFileContentStringBIN f0 p0
                      andalso isFileContentStringBIN f1 p1) then
                    (chat "[No writing: valid pickle strings already in eb-files.]")
                  else (writePickle f0 p0 ; writePickle f1 p1)
               end
             | NOT_ALPHA_EQUAL =>
               case (unpickleGen ofile pu_NB0 ext0,
                     unpickleGen ofile pu_NB1 ext1) of
                   (SOME NB0_0, SOME NB1_0) =>
                   let val (NB0,NB1) =
                           let val () = rename (#1 NB0_0,#1 NB1_0) (#1 NB0,#1 NB1)
                               val NB0 = matchGen Basis.matchBasis0 (NB0,NB0_0)
                               val _ = List.app Name.mk_rigid (#1 NB0)
                               val NB1 = matchGen Basis.matchBasis1 (NB1,NB1_0)
                               val _ = List.app Name.mk_rigid (#1 NB1)
                           in (NB0,NB1)
                           end
                   in if eqNB Basis.eqBasis0 (NB0,NB0_0) andalso
                         eqNB Basis.eqBasis1 (NB1,NB1_0) then ()
                      else pickleBoth(NB0,NB1)
                   end
                 | _ => pickleBoth(NB0,NB1)
        end

    type name = Name.name
    type modcode = MO.modcode
    type Basis0 = Basis.Basis0
    type Basis1 = Basis.Basis1

    fun pickleLnkFile smlfile ofile (modc: modcode) : unit =
        let val ext = "lnk"
            val p = doPickleGen0 smlfile ModCode.pu ext modc
            val file = targetFromOutput ofile ext
        in if isFileContentStringBIN file p then ()
           else writePickle file p
        end

    fun readLinkFiles lnkFiles =
        let fun process (nil,hce,modc) = modc
              | process (lf::lfs,hce,modc) =
                let val s = readFile lf
                            handle _ => die ("readLinkFiles.error reading file " ^ lf)
                    val (modc',hce) = Pickle.unpickle' ModCode.pu hce s
                                      handle _ => die ("readLinkFiles.error deserializing link code for " ^ lf)
                    val modc' = ModCode.dirMod (OS.Path.dir lf) modc'
                                handle _ => die ("readLinkFiles.error during dirMod modc'")
                in process(lfs,hce,ModCode.seq(modc,modc'))
                end
        in case lnkFiles of
               nil => ModCode.empty
             | lf::lfs =>
               let val s = readFile lf
                           handle _ => die ("readLinkFiles.error reading file " ^ lf)
                   val hce = Pickle.empty_hce()
                   val (modc,hce) = Pickle.unpickle' ModCode.pu hce s
                                    handle _ => die ("readLinkFiles.error deserializing link code for " ^ lf)
                   val modc = ModCode.dirMod (OS.Path.dir lf) modc
                              handle _ => die ("readLinkFiles.error during dirMod modc")
               in process(lfs,hce,modc)
               end
        end

    type InfixBasis = InfixBasis
    type ElabBasis = ElabBasis
    type hce = Pickle.hce

    type ElabBasesInfo = {ebfile : string,
                          infixElabBasis : InfixBasis*ElabBasis,
                          used : bool ref} list

    fun unpickleBases0 ebfiles : Pickle.hce * ElabBasesInfo =
        let val _ = chat "\n [Begin unpickling elaboration bases...]\n"
            fun process (nil,hce,acc) = (hce, rev acc)
              | process (ebfile::ebfiles,hce,acc) =
                let val s = readFile ebfile handle _ => die("unpickleBases0.error reading file " ^ ebfile)
                    val ((_,infixElabBasis),hce) =
                        Pickle.unpickle' pu_NB0 hce s
                        handle _ => die("unpickleBases0.error unpickling infixElabBasis from file " ^ ebfile)
                    val entry = {ebfile=ebfile,infixElabBasis=infixElabBasis,
                                 used=ref false}
                in process(ebfiles,hce,entry::acc)
                end
        in
          case ebfiles of
              nil => (Pickle.empty_hce(),nil)
            | ebfile::ebfiles =>
              let val s = readFile ebfile
                          handle _ =>
                                 die("unpickleBases0.error reading file " ^ ebfile)
                  val hce = Pickle.empty_hce()
                  val ((_,infixElabBasis),hce) =
                      Pickle.unpickle' pu_NB0 hce s
                      handle Fail st =>
                             die("unpickleBases0.error unpickling infixElabBasis from file "
                                 ^ ebfile ^ ": Fail(" ^ st ^ "); sz(s) = " ^ Int.toString (size s))
                           | e =>
                             die("unpickleBases0.error unpickling infixElabBasis from file "
                                 ^ ebfile ^ ": " ^ General.exnMessage e)
                  val (hce, entries) =
                      process(ebfiles,hce,[{ebfile=ebfile,
                                            infixElabBasis=infixElabBasis,
                                            used=ref false}])
              in (hce, entries)
              end handle _ => die ("unpickleBases0. error \n")
        end

    type opaq_env = opaq_env
    type IntBasis = IntBasis

    fun unpickleBases1 (hce: Pickle.hce) ebfiles : opaq_env * IntBasis =
        let val _ = chat "\n [Begin unpickling compiler bases...]\n"
            fun process (nil,hce,basisPair) = basisPair
              | process (ebfile::ebfiles,hce,basisPair) =
                let val s = readFile ebfile
                    val ((_,basisPair'),hce) = Pickle.unpickle' pu_NB1 hce s
                in process(ebfiles,hce,Basis.plusBasis1(basisPair,basisPair'))
                end
            val basisPair0 = Basis.initialBasis1()
        in case ebfiles of
               nil => basisPair0
             | ebfile::ebfiles =>
               let val s = readFile ebfile
                   val ((_,basisPair),hce) = Pickle.unpickle' pu_NB1 hce s
               in process(ebfiles,hce,Basis.plusBasis1(basisPair0,basisPair))
               end handle _ => die ("unpickleBases1. error \n")
        end

    fun lnkFileConsistent {lnkFile} =
        let val s = readFile lnkFile
            val mc = Pickle.unpickle ModCode.pu s
        in true
        end handle _ => false

    fun writeBasisJs toJsString punit ofile B =
        let val s = Pickle.pickle Basis.pu B
            val punit = String.translate (fn #"." => "_" | c => String.str c) punit
            val s = String.concat [punit, "_eb = ",
                                   toJsString s,
                                   ";"]
            val file = targetFromOutput ofile "eb.js"
        in writeTextFile file s
        end

    fun unpickleLnkFile (lnkfile: string) : modcode =
        let val s = readFile lnkfile  (* load modcode from lnk-file *)
        in Pickle.unpickle ModCode.pu s
        end
    end

    (* -------------------------------
     * Compute actual dependencies
     * ------------------------------- *)

    type longids = FreeIds.longids
    type funid = FreeIds.funid
    type sigid = FreeIds.sigid
    type longstrid = FreeIds.longstrid
    type longtycon = FreeIds.longtycon
    type longid = FreeIds.longid

    local
    fun lookup (look: ElabBasis -> 'a -> bool) elabBasesInfo (eb0:ElabBasis) (id:'a) =
        let fun loop nil =
              if look eb0 id then ()
              else die "computing actual dependencies.lookup failed"
              | loop ({ebfile,infixElabBasis=(_,eb),used}::xs) =
            if look eb id then used:=true
            else loop xs
        in loop elabBasesInfo
        end

    fun collapse (longstrids,longtycons,longvids) =
        let fun exists e l = List.exists (fn x => x = e) l
            fun ins e l = if exists e l then l else e::l
            val strids =
                foldl (fn (longstrid,acc) =>
                       case StrId.explode_longstrid longstrid of
                           (s::_,_) => ins s acc
                         | (nil,s) => ins s acc)
                nil longstrids
            val (strids,tycons) =
                foldl (fn (longtycon,(strids,tycons)) =>
                       case TyCon.explode_LongTyCon longtycon of
                           (s::_,_) => (ins s strids,tycons)
                         | (nil,tycon) => (strids,ins tycon tycons))
                (strids,nil) longtycons
            val (strids,vids) =
                foldl (fn (longvid,(strids,vids)) =>
                       case Ident.decompose longvid of
                           (s::_,_) => (ins s strids,vids)
                         | (nil,vid) => (strids,ins vid vids))
                (strids,nil) longvids
        in (vids,tycons,strids)
        end

    in
    fun compute_actual_deps
        (eb0:ElabBasis)
        (elabBasesInfo:{ebfile:string,infixElabBasis:InfixBasis*ElabBasis,used:bool ref}list)
        {funids,sigids,longstrids,longtycons,longvids} =
        let val (vids,tycons,strids) = collapse (longstrids,longtycons,longvids)
            fun look_vid B vid = Option.isSome
                (Environments.VE.lookup(Environments.E.to_VE(ElabBasis.to_E B)) vid)
            fun look_tycon B tycon = Option.isSome
                (Environments.TE.lookup(Environments.E.to_TE(ElabBasis.to_E B)) tycon)
            fun look_sigid B sigid = Option.isSome
                (ModuleEnvironments.G.lookup(ElabBasis.to_G B) sigid)
            fun look_funid B funid = Option.isSome
                (ModuleEnvironments.F.lookup(ElabBasis.to_F B) funid)
            fun look_strid B strid = Option.isSome
                (Environments.SE.lookup(Environments.E.to_SE(ElabBasis.to_E B)) strid)
            (* look into newest basis first *)
            val rev_elabBasesInfo = rev elabBasesInfo
        in    app (lookup look_vid rev_elabBasesInfo eb0) vids
            ; app (lookup look_tycon rev_elabBasesInfo eb0) tycons
            ; app (lookup look_strid rev_elabBasesInfo eb0) strids
            ; app (lookup look_sigid rev_elabBasesInfo eb0) sigids
            ; app (lookup look_funid rev_elabBasesInfo eb0) funids
            ; map #ebfile (List.filter (! o #used) elabBasesInfo)
        end
    end

    fun add_longstrid longstrid {funids, sigids, longstrids, longtycons, longvids} =
        let val longstrids = longstrid::longstrids
        in {funids=funids, sigids=sigids, longstrids=longstrids,
            longtycons=longtycons, longvids=longvids}
        end

    end (* structure PickleBases *)

    structure PB = PickleBases

    val debug = Flags.is_on0 "debug_compiler"

    local
      val messages_p = Flags.is_on0 "messages"
    in
      fun message f = if messages_p() then print(f())
                      else ()
    end

    fun maybe_print_topdec s topdec =
	if print_post_elab_ast() orelse debug() then
	    let val _ = print (s ^ ":\n")
		val st = PostElabTopdecGrammar.layoutTopdec topdec
	    in pr_st st
	    end
	else ()

    (* -------------------------------------------------------------------
     * Build SML source file for mlb-project ; flag compile_only enabled
     * ------------------------------------------------------------------- *)

    fun build_mlb_one (mlbfile, ebfiles, smlfile) : unit =
        let (* load the bases that smlfile depends on *)
            val () = message (fn () => "[reading source file:\t" ^ smlfile)
            val (unpickleStream, elabBasesInfo) = PB.unpickleBases0 ebfiles
            val initialBasis0 = Basis.initialBasis0()
            val (infB,elabB) =
                List.foldl (fn ({infixElabBasis,...}, acc) =>
                            Basis.plusBasis0(acc,infixElabBasis))
                initialBasis0
                elabBasesInfo
            val () = message (fn () => "]")
            val log_cleanup = log_init smlfile
            val _ = Flags.reset_warnings ()
            val abs_mlbfile = ModuleEnvironments.mk_absprjid mlbfile
(*          val _ = (print "Names generated prior to compilation: ";
                     PP.printTree (PP.layout_list (PP.LEAF o (fn (i,s) => s ^ "#" ^ Int.toString i) o Name.key) (!Name.bucket));
                     print "\n")
*)
            val _ = Name.bucket := []
            val base = mlbfile (* ^ "." ^ smlfile *) (* already appended in MlbMake! *)
            val _ = Name.baseSet base
            val res = ParseElab.parse_elab {absprjid = abs_mlbfile,
                                            src = ParseElab.SrcFile smlfile,
                                            infB = infB, elabB = elabB}
        in (case res of
                ParseElab.FAILURE (report, error_codes) =>
                    (  print "\n"
                     ; print_error_report report
                     ; raise PARSE_ELAB_ERROR error_codes)
              | ParseElab.SUCCESS {doreport,infB=infB',elabB=elabB',topdec} =>
              let
	        val _ = maybe_print_topdec "AST after elaboration" topdec
                val _ = chat "[finding free identifiers begin...]"
                val freelongids =
                    let val intinfrep = StrId.mk_LongStrId ["IntInfRep"]
                    in PB.add_longstrid intinfrep (FreeIds.fid_topdec topdec)
                    end
                val _ = chat "[finding free identifiers end...]"

                val _ = chat "[computing actual dependencies begin...]"
                val ebfiles_actual = PB.compute_actual_deps
                    (#2 initialBasis0) elabBasesInfo freelongids
                val ebfiles_actual = map (fn x => x ^ "1") ebfiles_actual
                val _ = chat "[computing actual dependencies end...]"

                val (B_im,_) =
                    let val (opaq_env,intB) =
                        PB.unpickleBases1 unpickleStream ebfiles_actual
                        val B = Basis.mk(infB,elabB,opaq_env,intB)
                    in Basis.restrict(B,freelongids)
                    end
                val () = message (fn () => "\n")
                val (_,_,opaq_env_im,intB_im) = Basis.un B_im

                (* Setting up for generation of second export basis (eb1) *)
                val names_elab = !Name.bucket
                val _ = List.app Name.mk_rigid names_elab
                val _ = Name.bucket := []
                val _ = Name.baseSet (base ^ "1")

                val _ = chat "[opacity elimination begin...]"
                val (topdec', opaq_env') = OpacityElim.opacity_elimination(opaq_env_im, topdec)
                val _ = chat "[opacity elimination end...]"

	        val _ = maybe_print_topdec "AST after opacity elimination" topdec

                val _ = chat "[interpretation begin...]"
                val (intB', modc) =
                    IntModules.interp(inline_functors(), abs_mlbfile,
                                      intB_im, topdec', smlfile)
                val names_int = !Name.bucket
                val _ = List.app Name.mk_rigid names_int
                val _ = Name.bucket := []
                val _ = chat "[interpretation end...]"

                (* compute result basis *)
                val B' = Basis.mk(infB',elabB',opaq_env',intB')

                (* Construct export bases *)
                val _ =
                    if print_export_bases() then
                      (  print ("[Export basis for " ^ smlfile ^ " before closure:]\n")
                       ; pr_st (MO.Basis.layout B')
                       ; print "\n")
                    else ()

                val B'Closed = Basis.closure (B_im,B')

                val _ =
                    if print_closed_export_bases() then
                      (  print ("[Closed export basis for " ^ smlfile ^ ":]\n")
                       ; pr_st (MO.Basis.layout B'Closed)
                       ; print "\n")
                    else ()

                val (NB0',NB1') =
                    let val (b1,b2,b3,b4) = Basis.un B'Closed
                    in ((names_elab,(b1,b2)),
                        (names_int, (b3,b4)))
                    end

                (* Write export bases to disk if there are not
                 * already identical export bases on disk *)
                val ofile = Flags.get_string_entry "output"
                val _ = PB.pickleNB smlfile ofile (NB0',NB1')

                val modc = ModCode.emit (abs_mlbfile,modc)
                val _ = PB.pickleLnkFile smlfile ofile modc

                (* Maybe write smlfile.eb.js to disk with export basis binding
                 * for JavaScript loading *)
                val () = if MO.export_basis_js()
                         then case MO.toJSString of
                                  SOME toJsString =>
                                  PB.writeBasisJs toJsString smlfile ofile B'Closed
                                | NONE => die "toJsString error"
                         else ()

              in print_result_report (doreport NONE);
                log_cleanup()
              end handle ? => (print_result_report (doreport NONE); raise ?)
                ) handle XX => (log_cleanup(); raise XX)
      end

     fun writeAll (f,s) =
         let val os = TextIO.openOut f
         in (TextIO.output(os,s);
             TextIO.closeOut os)
             handle X => (TextIO.closeOut os; raise X)
         end

    (* ------------------------------------------------
     * Link together lnk-files and generate executable
     * and a link-file for the mlbfile (to be used by
     * the REPL.
     * ------------------------------------------------ *)

    structure MlbProject = MlbProject(ManagerObjects.Environment)

    fun link_lnk_files (mlbfile_opt:string option) : unit =
        let val _ = chat "reading link files"
            val lnkFiles = link_code()
            val modc = PB.readLinkFiles lnkFiles
        in chat "making executable"
         ; ModCode.mk_exe_all_emitted(modc, nil, run_file())
         ; case mlbfile_opt of
               SOME mlbfile =>
               let val {dir,file} = OS.Path.splitDirFile mlbfile
                   val output = dir ## MO.mlbdir() ## file (* .lnk added by pickleLnkFile... *)
                   val target = Flags.lookup_string_entry "output"
                   val save = !target
                   fun doit () =
                       let val modc = ModCode.subMod dir modc
                       in target := output
                        ; chat "making mlb-linkfile"
                        ; PB.pickleLnkFile mlbfile output modc
                        ; target := save
                       end
               in case modTime (output ^ ".lnk") of
                      SOME t_mlb_lnk =>
                      if (case modTime mlbfile of
                              NONE => false
                            | SOME t_mlb => Time.>=(t_mlb_lnk,t_mlb))
                         andalso
                         List.all (fn lf =>
                                      case modTime lf of
                                          SOME t => Time.>= (t_mlb_lnk, t)
                                        | NONE => false) lnkFiles
                      then ()
                      else doit()
                    | NONE => doit()
               end
             | NONE => ()
        end

    (* ----------------------------
     * Build an MLB project
     * ---------------------------- *)

    exception IsolateFunExn of int

    structure MlbPlugIn : MLB_PLUGIN =
      struct
        local
          local
            val pids = ref []
          in
            fun add pid = pids := pid::(!pids)
            fun remove pid = pids := (List.mapPartial (fn p => if p = pid then NONE else SOME p) (!pids))
            fun killrest () = (List.app (fn p => Posix.Process.kill (Posix.Process.K_PROC p, Posix.Signal.term)) (!pids) ;
                               List.app (fn p => ignore (Posix.Process.waitpid (Posix.Process.W_CHILD p,[]))) (!pids) ;
                               pids := [])
          end
          fun ppSignal s =
              let open Posix.Signal
                  val ss = [(abrt,"abrt"),(alrm,"alrm"),(bus,"bus"),(fpe,"fpe"),(hup,"hup"),(ill,"ill"),
                            (int,"int"),(kill,"kill"),(pipe,"pipe"),(quit,"quit"),(segv,"segv"),(term,"term"),
                            (usr1,"usr1"),(usr2,"usr2"),(chld,"chld"),(cont,"cont"),(stop,"stop"),(tstp,"tstp"),
                            (ttin,"ttin"),(ttou,"ttou")]
              in case List.find (fn (s',_) => s=s') ss of
                     SOME (_,str) => str
                   | NONE => "unknown"
              end
          fun failSig s signal =
              raise Fail ("isolate error: " ^ s ^ "(HEX:" ^
                          SysWord.toString (Posix.Signal.toWord signal) ^ ", " ^
                          ppSignal signal ^ ")")
          fun errSubProcess source_opt e =
              case e of
                  Report.DeepError r =>
                  let val r0 = Report.line ("Region annotation error" ^
                                            (case source_opt of
                                                 SOME f => " in " ^ f
                                               | NONE => "."))
                  in print_error_report r (*(Report.//(r0, r))*)
                  end
                | PARSE_ELAB_ERROR _ => ()
                | IO.Io {name,function,cause} =>
                  (print ("[[ERR in sub process: Io{name=" ^ name
                          ^ ", function=" ^ function
                          ^ ", cause=" ^ General.exnMessage cause ^ "}]]\n"))
                | _ => (print "[[ERR in sub process:\n  ";
                        print (General.exnMessage e ^ "]]\n"))
        in
          fun isolate2 source (f : 'a -> unit) (a:'a) : Posix.Process.pid =
              case Posix.Process.fork()
               of SOME pid => (add pid ; pid)
                | NONE => ((f a ; Posix.Process.exit 0w0)
                           handle e => (errSubProcess (SOME source) e;
                                        Posix.Process.exit 0w1))
          fun wait p =
              let
                val (pid,st) = case p
                                of NONE => Posix.Process.wait()
                                 | SOME p => Posix.Process.waitpid (Posix.Process.W_CHILD p,[])
              in
                case st
                 of Posix.Process.W_EXITED => (remove pid ; pid)
                  | Posix.Process.W_EXITSTATUS n => (remove pid ; killrest (); raise IsolateFunExn (Word8.toInt n))
                  | Posix.Process.W_STOPPED s => (remove pid ; killrest (); failSig "W_STOPPED" s)
                  | Posix.Process.W_SIGNALED s => (remove pid ; killrest (); failSig "W_SIGNALED - wait" s)
              end handle OS.SysErr t => (killrest (); failSig "OS.SysErr" (Posix.Signal.fromWord 0w0))

          fun isolate (f : 'a -> unit) (a:'a) : unit =
              case Posix.Process.fork() of
                SOME pid => (* parent *)
                let val (pid2,status) = Posix.Process.waitpid (Posix.Process.W_CHILD pid,[])
                in if pid2 = pid then
                     (case status of
                        Posix.Process.W_EXITED => ()
                      | Posix.Process.W_EXITSTATUS n => raise IsolateFunExn (Word8.toInt n)
                      | Posix.Process.W_STOPPED s => failSig "W_STOPPED" s
                      | Posix.Process.W_SIGNALED s => failSig "W_SIGNALED - isolate" s)
                   else raise Fail "isolate error 2"
                end
              | NONE => (f a before Posix.Process.exit 0w0        (* child *)
                         handle e =>
                                (errSubProcess NONE e;
                                 Posix.Process.exit 0w1))
        end

        local
          fun unlock lockfile = (Posix.FileSys.unlink lockfile) handle _ => ()
          fun lock unique lockfile =
              let
                val fu =
                    (Posix.IO.close (Posix.FileSys.creat (lockfile ^ unique,Posix.FileSys.S.iwusr)) ; true)
                    handle OS.SysErr _ => false
                val f = if fu then
                          (Posix.FileSys.link{old=lockfile ^ unique, new=lockfile}; true)
                          handle OS.SysErr _ => Posix.FileSys.ST.nlink (Posix.FileSys.stat (lockfile ^ unique)) = 2
                        else false
              in if fu then (Posix.FileSys.unlink (lockfile ^ unique); f) handle _ => f
                 else false
              end

          fun compile0 target flags lockfile unique a =
              let
                (* deal with annotations (from mlb-file) *)
                val flags = String.tokens Char.isSpace flags
                val () = List.app Flags.turn_on flags
                val () = Flags.turn_on "compile_only"
                val () = Flags.lookup_string_entry "output" := target
              in (build_mlb_one a before (case lockfile of NONE => () | SOME lf => unlock lf))
              end handle ? => ((case lockfile of NONE => () | SOME lf => unlock lf) ;
                               case ? of Fail s => ( print ("Compile error: " ^ s ^ "\n"))
                                       | ? => raise ?)
        in
          fun compile {verbose} {basisFiles,lockfile,unique,source,namebase,target,flags} : Posix.Process.pid option =
              (fn f => case lockfile
                        of NONE => SOME (f ())
                         | SOME lf => if lock (Int.toString unique) lf then SOME (f ())
                                      else NONE)
                  (fn () => (isolate2 source (compile0 target flags lockfile (Int.toString unique)) (namebase, basisFiles, source)))
        end

        val getParallelN =
            Flags.add_int_entry
                {long="parallel_compilation", short = SOME "j",
                 menu=["General Control", "number of parallel compilation processes"],
                 item=ref 1,
                 desc="The maximum number of parallel processes used\n\
                      \for compilation."
                }
        local
          fun link0 mlbfile target lnkFiles () =
              (Flags.lookup_string_entry "output" := target;
               Flags.lookup_stringlist_entry "link_code" := lnkFiles;
               link_lnk_files (SOME mlbfile))
        in
          fun link {verbose} {mlbfile,target,lnkFiles,flags=""} :unit =
             isolate (link0 mlbfile target lnkFiles) ()
            | link _ _ = die "MlbPlugIn.link.flags non-empty"
        end

        fun mlbdir () = MO.mlbdir()
        fun objFileExt () = ".o"

        fun maybeSetRegionEffectVarCounter n =
            let
              val b = region_profiling()
              val _ = if b then Flags.lookup_int_entry "regionvar" := n
                      else ()
            in b
            end

        val lnkFileConsistent = PB.lnkFileConsistent
      end (* struct *)


    structure MlbMake = MlbMake(structure MlbProject = MlbProject
                                structure MlbPlugIn = MlbPlugIn
                                val verbose = Flags.is_on0 "chat"
                                val oneSrcFile : string option ref = ref NONE)

    datatype source = SML of string | MLB of string | WRONG_FILETYPE of string

    fun determine_source (s:string) : source =
        let fun wrong s = WRONG_FILETYPE ("File name must have extension '.mlb', '.sml', or '.sig'.\n" ^
                                          "*** The file name you gave me has " ^ s)
        in case OS.Path.ext s of
            SOME "mlb" => MLB s
          | SOME ext => if Flags.has_sml_source_ext ext then SML s
                        else wrong ("extension " ^ quot ext ^ ".")
          | NONE => wrong ("no extension.")
        end

    val import_basislib = Flags.is_on0 "import_basislib"
    fun gen_wrap_mlb smlfilepath =
        let val mlb_filepath = OS.Path.base smlfilepath ^ ".auto.mlb"
            val _ = chatf (fn () => "Generating MLB-file " ^ mlb_filepath)
            val os = TextIO.openOut mlb_filepath
            val basislib = !Flags.install_dir ## "basis/basis.mlb"
            val _ = chatf (fn() => "Using basis library " ^ quot basislib)
            val smlfile = OS.Path.file smlfilepath
            val body =
                if import_basislib() then
                    "local " ^ basislib ^ " in " ^ smlfile ^ " end"
                else smlfile
        in
            let val _ = TextIO.output(os, body)
                val _ = TextIO.closeOut os
            in mlb_filepath
            end handle X => (TextIO.closeOut os; raise X)
        end

    fun comp0 file : unit =
        case link_code() of
            _ :: _ => link_lnk_files NONE
          | nil =>
          case determine_source file of
            SML s =>
            if Flags.is_on "compile_only" then
              let val ebfiles = load_basis_files()
              in build_mlb_one (namebase(), ebfiles, s)
              end
            else
              let val mlb_file = gen_wrap_mlb s
                val _ = comp0 mlb_file
                    handle X => (OS.FileSys.remove mlb_file; raise X)
              in OS.FileSys.remove mlb_file
              end
          | MLB s =>
            let val target = Flags.get_string_entry "output"
            in
              (MlbMake.build{flags="",mlbfile=s,target=target}
               handle Fail s => raise Fail s
                    | OS.SysErr (s,_) =>
                      (print "Stopping compilation due to system error:\n";
                       print ("SysErr(" ^ s ^ ")\n");
                       raise PARSE_ELAB_ERROR nil)
                    | IsolateFunExn n =>
                      (print ("Stopping compilation of MLB-file due to error (code "
                              ^ Int.toString n ^ ").\n");
                       raise PARSE_ELAB_ERROR nil)
                    | ? => (print "Stopping compilation due to errors.\n";
                            print (General.exnMessage ? ^ "\n");
                            raise PARSE_ELAB_ERROR nil))
            end
          | WRONG_FILETYPE s => raise Fail s

    val timingfile = "KITtimings"
    fun comp file : unit =
      if Flags.is_on "compiler_timings" then
        let val os = (TextIO.openOut (timingfile)
                      handle _ => (print ("Error: I could not open file `" ^ timingfile ^ "' for writing");
                                   raise PARSE_ELAB_ERROR nil))
          fun close () = (TextIO.closeOut os;
                          Flags.timings_stream := NONE;
                          print ("[wrote compiler timings file: "  ^ timingfile ^ "]\n"))
        in Flags.timings_stream := SOME os;
          comp0 file handle E => (close(); raise E);
            close()
        end
      else comp0 file
  end
