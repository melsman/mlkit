functor TopdecLrVals(
           Token: TOKEN
         )
         = 
struct
structure ParserData=
struct
structure Header = 
struct
(* Grammar for top-level declarations.                  NICK, August 1990. *)

(* We have some divergences from the grammar described in the definition
   document. This is because the correct parsing of SML sometimes requires
   left context to be carried a rather horrific distance into the parse.
   In these cases, we parse a slightly more general syntactic form which
   conforms to LR(1), and then knock out the illegal forms in the reduction
   semantic rules.

        (i)     The parser doesn't know about infix status at all. I had a
                bash at doing a preprocessor which attached the correct infix
                status to identifiers, but it was a bit of a nightmare, and
                dealing with "*" and "=" as well became a *lot* of a nightmare.
                So, all application expressions, patterns and so on are
                parsed just as chains of atomic exp's/pat's. Any infixed
                identifiers are resolved later. This means we have to hang
                onto the "op" attached to identifiers, to be aware of the
                difference between

                        f + g

                and

                        f op+ g

        (ii)    This grammar parses `<Pat> as <Pat>', and eliminates illegal
                forms (`<Pat> as ...' where <Pat> is not an <OpId> or
                <OpId> : <Ty>) in the reduction rules. This is because a
                correct parse of

                        fun F(X : ty as ...)

                requires infinite lookahead to determine whether the `X' can
                be reduced to an <AtPat>, or whether there's an `as'-clause
                following the type expression. This could conceivably be
                fixed in the grammar (much like the disambiguating of LOCAL)
                but would add considerable complexity.

        (iii)   <FValBind> function bindings are a nightmare. The expression

                        fun (A infix1 B) infix2 C = ...

                is ambiguous because `A <infix1> B' should be read as two
                infix-separated <AtPat>'s *unless* there's an infix following
                the closing bracket, in which case `A <infix1> B' is part of
                a bracketted <Pat>.

                Because we're resolving infix in a post-pass anyway, this gets
                deferred. The functor Infixing() does all the work - look to
                that for more details.

        (iv)    The grammar actually accepts `op =' in a pattern. This is
                because we want to define equality in terms of the bool type
                declared in the prelude, which precludes us from building `='
                into the initial environment. We reject subsequent declarations
                of `=' during semantic analysis.

                I hate this language.

        (v)     Hey, guess what, I've found another one. Which of the
                following is legal?

                        val rec f = fn x => x: int
                        val rec f = (fn x => x)
                        val rec f = (fn x => x): int -> int

                The Definition is rather political about this (i.e. it
                contradicts itself and doesn't make a commitment one way
                or the other). I've decided to allow the first and third
                alternatives (i.e. `fn match' or `(fn match) : ty') which
                seem to be sort-of in the spirit of the definition. I'm
                making the second form illegal to stop programmers getting
                cocky.

                [MEMO: a couple of remaining bugs. Firstly, nested LOCAL
                 declarations are not handled correctly (see the bug list).
                 Secondly, we aren't lexing the correct tokens for numeric
                 record labels.
                ]

        (vi)    Whoops, just found something else. Semicolon dec/strdec/spec
                separators are difficult to do as per the Definition, since
                they are optional everywhere and they separate optional (i.e.
                possibly empty) phrases. We deal with this by giving ";"
                the same status as the phrase class it serves to separate.
                The `compose' functions from GrammarUtils are to swallow
                empty absyn phrases which can result from this treatment.
                Needless to say, this all means that we can't reconstitute
                semicolons in the source (that would require an abstract
                syntax class for them at least). Tough. Real SML programmers
                don't use semicolons.
 *)

open GrammarUtils
open M (*from inside GrammarUtils*)
open DecGrammar (*from inside TopdecGrammar*)
open LexBasics
type arg = unit


end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\133\001\003\000\132\001\004\000\131\001\008\000\130\001\
\\019\000\129\001\021\000\177\001\022\000\128\001\040\000\127\001\
\\041\000\126\001\053\000\124\001\000\000\
\\001\000\001\000\133\001\003\000\132\001\004\000\131\001\008\000\130\001\
\\019\000\129\001\022\000\128\001\040\000\127\001\041\000\126\001\
\\046\000\125\001\053\000\124\001\000\000\
\\001\000\005\000\063\001\061\000\030\000\074\000\020\000\000\000\
\\001\000\007\000\117\001\009\000\055\000\010\000\054\000\030\000\116\001\
\\061\000\030\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\017\000\052\000\023\000\049\000\
\\026\000\047\000\030\000\044\000\034\000\041\000\037\000\039\000\
\\044\000\036\000\045\000\035\000\046\000\093\000\047\000\034\000\
\\049\000\033\000\059\000\032\000\060\000\031\000\061\000\030\000\
\\063\000\029\000\064\000\028\000\065\000\027\000\066\000\026\000\
\\067\000\025\000\068\000\024\000\069\000\023\000\070\000\022\000\
\\073\000\021\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\017\000\052\000\023\000\049\000\
\\026\000\047\000\030\000\044\000\034\000\041\000\037\000\039\000\
\\044\000\036\000\045\000\035\000\047\000\034\000\049\000\033\000\
\\059\000\032\000\060\000\031\000\061\000\030\000\063\000\029\000\
\\064\000\028\000\065\000\027\000\066\000\026\000\067\000\025\000\
\\068\000\024\000\069\000\023\000\070\000\022\000\073\000\021\000\
\\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\030\000\044\000\034\000\041\000\
\\045\000\035\000\047\000\034\000\049\000\033\000\059\000\032\000\
\\060\000\031\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\070\000\022\000\073\000\021\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\041\000\060\000\031\000\
\\061\000\030\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\038\000\108\000\
\\045\000\107\000\047\000\106\000\049\000\105\000\055\000\104\000\
\\059\000\103\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\074\000\020\000\075\000\102\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\038\000\108\000\
\\045\000\144\000\047\000\106\000\049\000\105\000\055\000\104\000\
\\059\000\103\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\038\000\213\000\
\\045\000\144\000\047\000\106\000\049\000\105\000\055\000\104\000\
\\059\000\103\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\045\000\107\000\
\\047\000\106\000\049\000\105\000\055\000\104\000\059\000\103\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\074\000\020\000\075\000\102\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\046\000\210\000\047\000\106\000\049\000\105\000\055\000\104\000\
\\059\000\103\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\046\000\210\000\047\000\106\000\049\000\105\000\055\000\104\000\
\\059\000\103\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\074\000\020\000\075\000\209\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\047\000\106\000\049\000\105\000\055\000\104\000\059\000\103\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\040\000\197\001\061\000\030\000\
\\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\060\000\118\000\061\000\030\000\
\\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\060\000\214\000\061\000\030\000\
\\074\000\020\000\000\000\
\\001\000\009\000\055\000\010\000\054\000\061\000\030\000\074\000\020\000\000\000\
\\001\000\009\000\174\000\045\000\173\000\049\000\172\000\074\000\153\000\
\\075\000\171\000\000\000\
\\001\000\009\000\174\000\074\000\153\000\000\000\
\\001\000\011\000\118\001\046\000\229\001\000\000\
\\001\000\012\000\249\000\021\000\021\002\052\000\248\000\000\000\
\\001\000\012\000\249\000\046\000\251\001\052\000\248\000\000\000\
\\001\000\012\000\138\001\059\000\137\001\061\000\030\000\062\000\136\001\
\\074\000\020\000\000\000\
\\001\000\015\000\064\000\018\000\191\000\025\000\063\000\036\000\062\000\
\\052\000\061\000\000\000\
\\001\000\015\000\064\000\020\000\101\001\025\000\063\000\036\000\062\000\
\\052\000\061\000\000\000\
\\001\000\015\000\064\000\021\000\099\001\025\000\063\000\036\000\062\000\
\\052\000\061\000\053\000\188\000\000\000\
\\001\000\015\000\064\000\025\000\063\000\033\000\242\000\036\000\062\000\
\\052\000\061\000\000\000\
\\001\000\015\000\064\000\025\000\063\000\036\000\062\000\039\000\224\000\
\\052\000\061\000\000\000\
\\001\000\015\000\064\000\025\000\063\000\036\000\062\000\046\000\190\000\
\\051\000\189\000\052\000\061\000\053\000\188\000\000\000\
\\001\000\016\000\039\003\050\000\039\003\051\000\039\003\052\000\227\000\
\\060\000\087\002\000\000\
\\001\000\016\000\197\000\046\000\030\001\051\000\029\001\052\000\196\000\000\000\
\\001\000\016\000\197\000\052\000\196\000\057\000\233\000\000\000\
\\001\000\016\000\197\000\052\000\196\000\060\000\195\000\000\000\
\\001\000\016\000\197\000\052\000\196\000\060\000\032\001\000\000\
\\001\000\019\000\052\001\034\000\148\000\061\000\030\000\074\000\020\000\000\000\
\\001\000\019\000\011\002\034\000\148\000\061\000\030\000\074\000\020\000\000\000\
\\001\000\021\000\097\001\000\000\
\\001\000\021\000\098\001\000\000\
\\001\000\021\000\111\001\000\000\
\\001\000\021\000\159\001\000\000\
\\001\000\021\000\222\001\000\000\
\\001\000\021\000\227\001\000\000\
\\001\000\023\000\095\001\045\000\094\001\000\000\
\\001\000\023\000\155\001\000\000\
\\001\000\027\000\218\000\000\000\
\\001\000\027\000\220\000\000\000\
\\001\000\027\000\038\001\000\000\
\\001\000\027\000\226\001\000\000\
\\001\000\034\000\148\000\061\000\030\000\074\000\020\000\000\000\
\\001\000\040\000\176\001\000\000\
\\001\000\042\000\244\000\043\000\243\000\000\000\
\\001\000\042\000\110\001\000\000\
\\001\000\045\000\113\000\074\000\153\000\075\000\102\000\000\000\
\\001\000\045\000\251\000\000\000\
\\001\000\046\000\186\000\000\000\
\\001\000\046\000\187\000\000\000\
\\001\000\046\000\027\001\000\000\
\\001\000\046\000\028\001\000\000\
\\001\000\046\000\078\001\000\000\
\\001\000\046\000\080\001\051\000\079\001\000\000\
\\001\000\046\000\249\001\000\000\
\\001\000\046\000\252\001\000\000\
\\001\000\047\000\164\000\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\047\000\018\001\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\047\000\070\001\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\047\000\140\001\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\047\000\214\001\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\047\000\247\001\060\000\074\000\061\000\030\000\062\000\073\000\
\\074\000\020\000\000\000\
\\001\000\048\000\184\000\000\000\
\\001\000\048\000\025\001\000\000\
\\001\000\048\000\068\001\000\000\
\\001\000\048\000\149\001\000\000\
\\001\000\048\000\203\001\000\000\
\\001\000\048\000\244\001\000\000\
\\001\000\048\000\018\002\000\000\
\\001\000\048\000\041\002\000\000\
\\001\000\050\000\183\000\000\000\
\\001\000\050\000\024\001\000\000\
\\001\000\050\000\077\001\000\000\
\\001\000\052\000\076\001\000\000\
\\001\000\052\000\122\001\000\000\
\\001\000\052\000\231\001\000\000\
\\001\000\052\000\237\001\000\000\
\\001\000\052\000\020\002\000\000\
\\001\000\053\000\000\000\078\000\000\000\000\000\
\\001\000\054\000\202\000\061\000\030\000\063\000\083\000\066\000\082\000\
\\074\000\020\000\000\000\
\\001\000\058\000\141\001\000\000\
\\001\000\060\000\074\000\061\000\030\000\062\000\073\000\074\000\020\000\000\000\
\\001\000\060\000\182\000\000\000\
\\001\000\060\000\238\000\000\000\
\\001\000\060\000\250\000\000\000\
\\001\000\060\000\022\001\000\000\
\\001\000\060\000\034\001\000\000\
\\001\000\060\000\040\001\000\000\
\\001\000\060\000\053\001\000\000\
\\001\000\060\000\059\001\000\000\
\\001\000\060\000\060\001\000\000\
\\001\000\060\000\230\001\000\000\
\\001\000\060\000\235\001\000\000\
\\001\000\060\000\238\001\000\000\
\\001\000\060\000\003\002\000\000\
\\001\000\060\000\012\002\000\000\
\\001\000\060\000\016\002\000\000\
\\001\000\060\000\022\002\000\000\
\\001\000\060\000\023\002\000\000\
\\001\000\060\000\061\002\000\000\
\\001\000\061\000\030\000\063\000\083\000\066\000\082\000\069\000\081\000\
\\074\000\020\000\000\000\
\\001\000\061\000\030\000\063\000\083\000\066\000\082\000\074\000\020\000\000\000\
\\001\000\061\000\030\000\074\000\020\000\000\000\
\\001\000\069\000\081\000\000\000\
\\001\000\071\000\077\000\072\000\076\000\000\000\
\\001\000\071\000\180\000\000\000\
\\001\000\074\000\153\000\000\000\
\\001\000\075\000\209\000\000\000\
\\065\002\000\000\
\\066\002\000\000\
\\067\002\000\000\
\\068\002\000\000\
\\069\002\000\000\
\\070\002\000\000\
\\071\002\000\000\
\\072\002\000\000\
\\073\002\000\000\
\\074\002\000\000\
\\075\002\000\000\
\\075\002\045\000\169\001\000\000\
\\076\002\000\000\
\\077\002\000\000\
\\078\002\000\000\
\\079\002\000\000\
\\080\002\000\000\
\\080\002\076\000\059\000\000\000\
\\081\002\000\000\
\\082\002\000\000\
\\083\002\000\000\
\\084\002\066\000\133\000\000\000\
\\085\002\000\000\
\\086\002\000\000\
\\087\002\000\000\
\\088\002\000\000\
\\089\002\000\000\
\\090\002\061\000\030\000\074\000\020\000\000\000\
\\091\002\000\000\
\\092\002\060\000\074\000\061\000\030\000\062\000\073\000\074\000\020\000\000\000\
\\093\002\000\000\
\\094\002\009\000\055\000\010\000\054\000\061\000\030\000\074\000\020\000\000\000\
\\095\002\000\000\
\\096\002\060\000\238\001\000\000\
\\097\002\000\000\
\\098\002\060\000\016\002\000\000\
\\099\002\000\000\
\\100\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\000\000\
\\101\002\002\000\058\000\006\000\057\000\008\000\056\000\009\000\055\000\
\\010\000\054\000\013\000\053\000\017\000\052\000\019\000\051\000\
\\022\000\050\000\023\000\049\000\024\000\048\000\026\000\047\000\
\\028\000\046\000\029\000\045\000\030\000\044\000\031\000\043\000\
\\032\000\042\000\034\000\041\000\035\000\040\000\037\000\039\000\
\\040\000\038\000\041\000\037\000\044\000\036\000\045\000\035\000\
\\047\000\034\000\049\000\033\000\059\000\032\000\060\000\031\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\070\000\022\000\073\000\021\000\074\000\020\000\077\000\019\000\000\000\
\\102\002\000\000\
\\103\002\000\000\
\\104\002\000\000\
\\105\002\000\000\
\\106\002\002\000\058\000\006\000\057\000\008\000\056\000\013\000\053\000\
\\019\000\051\000\022\000\050\000\024\000\048\000\028\000\046\000\
\\029\000\045\000\031\000\043\000\032\000\042\000\035\000\040\000\
\\040\000\038\000\041\000\037\000\077\000\019\000\000\000\
\\107\002\000\000\
\\108\002\000\000\
\\109\002\000\000\
\\110\002\012\000\249\000\052\000\248\000\000\000\
\\111\002\011\000\118\001\000\000\
\\112\002\011\000\118\001\000\000\
\\113\002\000\000\
\\114\002\012\000\249\000\014\000\025\002\052\000\248\000\000\000\
\\115\002\000\000\
\\116\002\000\000\
\\117\002\000\000\
\\118\002\011\000\118\001\014\000\038\002\000\000\
\\119\002\000\000\
\\120\002\000\000\
\\121\002\014\000\008\002\000\000\
\\122\002\000\000\
\\123\002\000\000\
\\124\002\056\000\049\002\000\000\
\\125\002\000\000\
\\126\002\000\000\
\\127\002\000\000\
\\128\002\000\000\
\\129\002\014\000\034\002\000\000\
\\130\002\000\000\
\\131\002\000\000\
\\132\002\014\000\004\002\000\000\
\\132\002\014\000\004\002\060\000\003\002\000\000\
\\133\002\000\000\
\\134\002\014\000\233\001\000\000\
\\135\002\000\000\
\\136\002\000\000\
\\137\002\000\000\
\\138\002\014\000\027\002\000\000\
\\139\002\000\000\
\\140\002\000\000\
\\141\002\000\000\
\\142\002\000\000\
\\143\002\000\000\
\\144\002\000\000\
\\145\002\000\000\
\\146\002\000\000\
\\147\002\011\000\118\001\000\000\
\\148\002\000\000\
\\149\002\000\000\
\\150\002\000\000\
\\151\002\000\000\
\\152\002\000\000\
\\153\002\000\000\
\\154\002\000\000\
\\154\002\061\000\030\000\074\000\020\000\000\000\
\\155\002\000\000\
\\156\002\000\000\
\\157\002\000\000\
\\158\002\000\000\
\\159\002\000\000\
\\160\002\000\000\
\\161\002\000\000\
\\162\002\000\000\
\\163\002\008\000\056\000\013\000\053\000\019\000\051\000\022\000\050\000\
\\024\000\048\000\028\000\046\000\029\000\045\000\031\000\043\000\
\\032\000\042\000\035\000\040\000\040\000\038\000\041\000\037\000\
\\053\000\124\000\077\000\019\000\000\000\
\\164\002\007\000\117\001\008\000\056\000\009\000\055\000\010\000\054\000\
\\013\000\053\000\019\000\051\000\022\000\050\000\024\000\048\000\
\\028\000\046\000\029\000\045\000\030\000\116\001\031\000\043\000\
\\032\000\042\000\035\000\040\000\040\000\038\000\041\000\037\000\
\\053\000\124\000\061\000\030\000\074\000\020\000\077\000\019\000\000\000\
\\164\002\008\000\056\000\013\000\053\000\019\000\051\000\022\000\050\000\
\\024\000\048\000\028\000\046\000\029\000\045\000\031\000\043\000\
\\032\000\042\000\035\000\040\000\040\000\038\000\041\000\037\000\
\\053\000\124\000\077\000\019\000\000\000\
\\165\002\000\000\
\\166\002\000\000\
\\167\002\000\000\
\\168\002\000\000\
\\169\002\000\000\
\\170\002\000\000\
\\171\002\000\000\
\\172\002\012\000\249\000\014\000\172\001\052\000\248\000\000\000\
\\173\002\000\000\
\\174\002\000\000\
\\174\002\061\000\030\000\074\000\020\000\000\000\
\\175\002\000\000\
\\176\002\000\000\
\\177\002\000\000\
\\178\002\014\000\056\002\000\000\
\\179\002\000\000\
\\180\002\000\000\
\\181\002\000\000\
\\182\002\011\000\118\001\014\000\121\001\000\000\
\\183\002\076\000\065\000\000\000\
\\184\002\000\000\
\\185\002\000\000\
\\186\002\000\000\
\\187\002\000\000\
\\188\002\076\000\010\001\000\000\
\\189\002\000\000\
\\190\002\000\000\
\\191\002\000\000\
\\192\002\000\000\
\\193\002\076\000\012\001\000\000\
\\194\002\000\000\
\\195\002\000\000\
\\196\002\000\000\
\\197\002\000\000\
\\198\002\000\000\
\\199\002\000\000\
\\200\002\000\000\
\\201\002\000\000\
\\202\002\000\000\
\\203\002\072\000\076\000\000\000\
\\204\002\000\000\
\\205\002\000\000\
\\206\002\009\000\055\000\010\000\054\000\030\000\044\000\034\000\041\000\
\\045\000\035\000\047\000\034\000\049\000\033\000\059\000\032\000\
\\060\000\031\000\061\000\030\000\063\000\029\000\064\000\028\000\
\\065\000\027\000\066\000\026\000\067\000\025\000\068\000\024\000\
\\069\000\023\000\070\000\022\000\073\000\021\000\074\000\020\000\000\000\
\\207\002\000\000\
\\208\002\000\000\
\\209\002\061\000\030\000\063\000\083\000\066\000\082\000\074\000\020\000\000\000\
\\210\002\000\000\
\\211\002\015\000\064\000\025\000\063\000\036\000\062\000\051\000\082\001\
\\052\000\061\000\000\000\
\\212\002\000\000\
\\213\002\009\000\055\000\010\000\054\000\017\000\052\000\023\000\049\000\
\\026\000\047\000\030\000\044\000\034\000\041\000\037\000\039\000\
\\044\000\036\000\045\000\035\000\047\000\034\000\049\000\033\000\
\\059\000\032\000\060\000\031\000\061\000\030\000\063\000\029\000\
\\064\000\028\000\065\000\027\000\066\000\026\000\067\000\025\000\
\\068\000\024\000\069\000\023\000\070\000\022\000\073\000\021\000\
\\074\000\020\000\000\000\
\\214\002\000\000\
\\215\002\015\000\064\000\025\000\063\000\036\000\062\000\051\000\185\000\
\\052\000\061\000\000\000\
\\216\002\000\000\
\\217\002\000\000\
\\218\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\
\\053\000\188\000\000\000\
\\219\002\000\000\
\\220\002\000\000\
\\221\002\000\000\
\\222\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\000\000\
\\223\002\000\000\
\\224\002\000\000\
\\225\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\000\000\
\\226\002\015\000\064\000\036\000\062\000\052\000\061\000\000\000\
\\227\002\015\000\064\000\052\000\061\000\000\000\
\\228\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\000\000\
\\229\002\000\000\
\\230\002\000\000\
\\231\002\056\000\232\000\000\000\
\\232\002\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\000\000\
\\233\002\000\000\
\\234\002\000\000\
\\235\002\000\000\
\\236\002\043\000\241\000\000\000\
\\237\002\043\000\240\000\000\000\
\\238\002\000\000\
\\239\002\000\000\
\\240\002\000\000\
\\241\002\000\000\
\\242\002\000\000\
\\243\002\000\000\
\\244\002\000\000\
\\245\002\000\000\
\\246\002\000\000\
\\247\002\000\000\
\\248\002\000\000\
\\249\002\000\000\
\\250\002\000\000\
\\251\002\000\000\
\\252\002\000\000\
\\253\002\000\000\
\\254\002\000\000\
\\255\002\000\000\
\\000\003\000\000\
\\001\003\013\000\053\000\019\000\051\000\022\000\050\000\024\000\048\000\
\\028\000\046\000\029\000\045\000\031\000\131\000\032\000\042\000\
\\035\000\040\000\040\000\038\000\041\000\037\000\053\000\130\000\
\\077\000\019\000\000\000\
\\002\003\013\000\053\000\019\000\051\000\022\000\050\000\024\000\048\000\
\\028\000\046\000\029\000\045\000\031\000\131\000\032\000\042\000\
\\035\000\040\000\040\000\038\000\041\000\037\000\053\000\130\000\
\\077\000\019\000\000\000\
\\003\003\000\000\
\\004\003\000\000\
\\005\003\000\000\
\\006\003\014\000\087\001\015\000\064\000\025\000\063\000\036\000\062\000\
\\052\000\061\000\000\000\
\\007\003\000\000\
\\008\003\000\000\
\\009\003\000\000\
\\010\003\000\000\
\\011\003\052\000\020\002\000\000\
\\012\003\000\000\
\\013\003\014\000\218\001\000\000\
\\014\003\000\000\
\\015\003\000\000\
\\016\003\014\000\158\001\000\000\
\\017\003\000\000\
\\018\003\000\000\
\\019\003\000\000\
\\020\003\000\000\
\\021\003\014\000\107\001\000\000\
\\022\003\000\000\
\\023\003\000\000\
\\024\003\056\000\164\001\000\000\
\\025\003\000\000\
\\026\003\000\000\
\\027\003\000\000\
\\028\003\014\000\046\001\000\000\
\\029\003\000\000\
\\030\003\000\000\
\\031\003\014\000\229\000\000\000\
\\032\003\000\000\
\\033\003\000\000\
\\034\003\015\000\064\000\025\000\063\000\036\000\062\000\052\000\061\000\
\\056\000\162\001\000\000\
\\035\003\000\000\
\\036\003\000\000\
\\037\003\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\047\000\106\000\049\000\105\000\055\000\104\000\059\000\103\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\074\000\020\000\000\000\
\\038\003\000\000\
\\039\003\052\000\227\000\000\000\
\\040\003\000\000\
\\041\003\033\000\236\000\000\000\
\\041\003\033\000\236\000\060\000\235\000\000\000\
\\042\003\000\000\
\\043\003\000\000\
\\044\003\000\000\
\\045\003\000\000\
\\046\003\076\000\192\000\000\000\
\\047\003\000\000\
\\048\003\000\000\
\\049\003\000\000\
\\050\003\000\000\
\\051\003\000\000\
\\052\003\000\000\
\\053\003\000\000\
\\054\003\054\000\202\000\061\000\030\000\063\000\083\000\066\000\082\000\
\\074\000\020\000\000\000\
\\055\003\000\000\
\\056\003\000\000\
\\057\003\000\000\
\\058\003\016\000\197\000\052\000\196\000\000\000\
\\059\003\016\000\090\001\000\000\
\\060\003\000\000\
\\061\003\016\000\197\000\051\000\152\001\052\000\196\000\000\000\
\\061\003\051\000\152\001\000\000\
\\062\003\000\000\
\\063\003\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\047\000\106\000\049\000\105\000\055\000\104\000\059\000\103\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\074\000\020\000\000\000\
\\064\003\000\000\
\\065\003\016\000\197\000\051\000\026\001\052\000\196\000\000\000\
\\066\003\000\000\
\\067\003\009\000\055\000\010\000\054\000\034\000\109\000\045\000\144\000\
\\047\000\106\000\049\000\105\000\055\000\104\000\059\000\103\000\
\\061\000\030\000\063\000\029\000\064\000\028\000\065\000\027\000\
\\066\000\026\000\067\000\025\000\068\000\024\000\069\000\023\000\
\\074\000\020\000\000\000\
\\068\003\000\000\
\\069\003\000\000\
\\070\003\016\000\197\000\052\000\196\000\000\000\
\\071\003\000\000\
\\072\003\000\000\
\\073\003\058\000\002\001\059\000\001\001\000\000\
\\074\003\009\000\174\000\061\000\000\001\074\000\153\000\000\000\
\\075\003\000\000\
\\076\003\000\000\
\\077\003\000\000\
\\078\003\076\000\212\001\000\000\
\\079\003\076\000\072\001\000\000\
\\080\003\000\000\
\\081\003\000\000\
\\082\003\044\000\254\000\000\000\
\\083\003\000\000\
\\084\003\000\000\
\\085\003\000\000\
\\086\003\000\000\
\\087\003\000\000\
\\088\003\051\000\079\001\000\000\
\\089\003\000\000\
\\090\003\000\000\
\\091\003\076\000\253\000\000\000\
\\092\003\000\000\
\\093\003\000\000\
\\094\003\076\000\143\001\000\000\
\\095\003\000\000\
\\096\003\000\000\
\\097\003\076\000\147\001\000\000\
\\098\003\000\000\
\\099\003\061\000\030\000\063\000\083\000\066\000\082\000\074\000\020\000\000\000\
\\100\003\000\000\
\\101\003\000\000\
\\102\003\051\000\210\001\000\000\
\\103\003\000\000\
\\104\003\000\000\
\\105\003\000\000\
\\106\003\000\000\
\\107\003\000\000\
\\108\003\000\000\
\\109\003\000\000\
\\110\003\000\000\
\\111\003\000\000\
\\112\003\000\000\
\\113\003\000\000\
\\114\003\045\000\113\000\075\000\102\000\000\000\
\\115\003\000\000\
\\116\003\000\000\
\\117\003\000\000\
\\118\003\051\000\031\001\000\000\
\"
val actionRowNumbers =
"\154\000\170\001\167\001\244\000\
\\133\000\130\000\126\000\223\000\
\\020\001\001\001\007\001\153\000\
\\240\000\159\000\159\000\159\000\
\\152\000\089\000\116\000\000\001\
\\112\000\169\001\171\001\168\001\
\\165\001\164\001\163\001\162\001\
\\117\000\134\000\108\000\010\001\
\\014\001\004\000\005\000\008\000\
\\173\001\005\000\018\000\016\000\
\\089\000\220\000\059\001\137\000\
\\137\000\005\000\011\000\014\000\
\\050\000\054\000\005\000\173\001\
\\129\000\128\000\110\000\110\000\
\\110\000\064\000\006\001\019\000\
\\005\000\014\000\005\000\089\000\
\\155\000\158\000\157\000\156\000\
\\145\000\120\000\051\001\122\000\
\\121\000\113\000\006\000\002\001\
\\141\000\252\000\140\000\166\001\
\\139\000\138\000\090\000\078\000\
\\009\001\013\001\070\000\016\001\
\\056\000\057\000\030\000\249\000\
\\025\000\104\001\009\000\127\001\
\\034\001\126\001\034\000\101\001\
\\174\001\111\000\100\001\112\001\
\\122\001\013\000\010\000\017\000\
\\172\001\036\001\114\000\115\000\
\\023\001\147\000\042\001\131\000\
\\135\000\045\001\218\000\217\000\
\\046\000\221\000\222\000\053\001\
\\054\001\058\001\057\001\047\000\
\\055\001\059\001\089\000\136\000\
\\089\000\029\000\014\000\096\001\
\\088\001\049\001\094\001\024\001\
\\032\001\033\000\012\000\099\001\
\\118\000\041\001\110\000\091\000\
\\114\000\038\001\037\001\123\000\
\\028\000\052\000\114\000\163\000\
\\224\000\092\000\236\000\055\000\
\\168\000\243\000\089\000\150\001\
\\124\000\141\001\133\001\132\001\
\\021\001\151\001\158\001\019\000\
\\125\000\027\001\022\001\028\001\
\\241\000\144\000\003\001\004\001\
\\005\000\245\000\255\000\005\000\
\\253\000\250\000\005\000\005\000\
\\248\000\005\000\065\000\035\001\
\\092\001\005\000\019\000\014\000\
\\093\000\031\000\079\000\111\001\
\\113\001\121\001\071\000\124\001\
\\058\000\059\000\032\000\177\001\
\\108\001\061\001\035\000\010\000\
\\105\001\094\000\146\000\216\000\
\\220\000\056\001\005\000\048\000\
\\044\001\043\001\005\000\050\001\
\\095\000\019\000\086\001\014\000\
\\093\001\030\001\014\000\005\000\
\\085\001\007\000\019\000\119\000\
\\036\000\096\000\173\001\173\001\
\\014\000\173\001\059\001\097\000\
\\098\000\162\000\002\000\002\000\
\\002\000\209\000\072\000\066\000\
\\110\000\138\001\019\000\110\000\
\\019\000\081\000\080\000\157\001\
\\060\000\061\000\005\001\012\001\
\\089\000\015\001\089\000\018\001\
\\019\001\017\001\029\001\103\001\
\\089\000\063\001\128\001\129\001\
\\014\000\117\001\106\001\110\001\
\\014\000\175\001\109\001\014\000\
\\107\001\115\000\044\000\066\001\
\\019\000\038\000\039\000\027\000\
\\059\001\026\000\005\000\095\001\
\\087\001\031\001\033\001\082\001\
\\050\000\085\001\132\000\097\001\
\\098\001\078\001\020\000\050\000\
\\047\001\046\001\025\001\053\000\
\\040\000\050\000\003\000\230\000\
\\164\000\208\000\165\000\239\000\
\\082\000\001\000\242\000\148\001\
\\089\000\024\000\067\000\134\001\
\\088\000\130\001\019\000\153\001\
\\020\000\019\000\156\001\008\001\
\\109\000\246\000\251\000\073\000\
\\060\001\009\000\119\001\120\001\
\\014\000\123\001\125\001\176\001\
\\045\000\014\000\073\001\225\000\
\\254\000\247\000\041\000\005\000\
\\091\001\084\001\083\001\081\001\
\\075\001\173\001\039\001\078\001\
\\059\001\040\001\078\001\211\000\
\\127\000\228\000\220\000\220\000\
\\051\000\000\000\237\000\110\000\
\\002\000\204\000\207\000\163\000\
\\089\000\173\001\110\000\054\000\
\\110\000\015\000\002\000\173\001\
\\074\000\143\001\110\000\110\000\
\\110\000\139\001\089\000\019\000\
\\161\001\089\000\137\001\146\001\
\\147\001\068\000\011\001\102\001\
\\062\001\114\001\087\000\115\001\
\\116\001\014\000\070\001\071\001\
\\173\001\052\001\026\001\089\001\
\\014\000\079\001\050\000\077\001\
\\076\001\042\000\074\001\219\000\
\\226\000\212\000\110\000\049\000\
\\043\000\232\000\173\001\229\000\
\\238\000\021\000\099\000\083\000\
\\193\000\114\000\202\000\188\000\
\\194\000\098\001\199\000\100\000\
\\114\000\197\000\196\000\084\000\
\\200\000\101\000\206\000\020\000\
\\231\000\203\000\201\000\114\000\
\\195\000\149\001\145\001\144\001\
\\142\001\075\000\131\001\159\001\
\\109\000\152\001\069\000\154\001\
\\089\000\118\001\062\000\064\001\
\\010\000\072\001\090\001\080\001\
\\048\001\023\000\063\000\227\000\
\\003\000\210\000\020\000\163\000\
\\003\000\019\000\186\000\173\001\
\\174\000\037\000\103\000\002\000\
\\018\000\104\000\205\000\143\000\
\\142\000\185\000\140\001\160\001\
\\135\001\089\000\076\000\085\000\
\\069\001\213\000\215\000\022\000\
\\105\000\106\000\167\000\192\000\
\\183\000\019\000\173\001\114\000\
\\187\000\172\000\110\000\098\001\
\\182\000\020\000\050\000\171\000\
\\149\000\148\000\020\000\077\000\
\\155\001\070\001\019\000\214\000\
\\019\000\003\000\161\000\110\000\
\\190\000\089\000\189\000\184\000\
\\102\000\173\000\177\000\179\000\
\\173\001\198\000\182\000\169\000\
\\110\000\151\000\150\000\136\001\
\\065\001\068\001\235\000\167\000\
\\166\000\191\000\175\000\050\000\
\\114\000\181\000\180\000\170\000\
\\067\001\233\000\051\000\160\000\
\\176\000\107\000\234\000\050\000\
\\182\000\178\000\086\000"
val gotoT =
"\
\\001\000\062\002\002\000\016\000\004\000\015\000\006\000\014\000\
\\007\000\013\000\052\000\012\000\067\000\011\000\070\000\010\000\
\\094\000\009\000\099\000\008\000\115\000\007\000\116\000\006\000\
\\121\000\005\000\122\000\004\000\123\000\003\000\126\000\002\000\
\\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\070\000\010\000\094\000\009\000\099\000\058\000\
\\116\000\006\000\121\000\005\000\122\000\004\000\123\000\003\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\002\000\065\000\003\000\064\000\004\000\015\000\006\000\014\000\
\\007\000\013\000\115\000\007\000\000\000\
\\002\000\065\000\003\000\066\000\004\000\015\000\006\000\014\000\
\\007\000\013\000\115\000\007\000\000\000\
\\002\000\065\000\003\000\067\000\004\000\015\000\006\000\014\000\
\\007\000\013\000\115\000\007\000\000\000\
\\000\000\
\\109\000\070\000\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\000\000\
\\095\000\073\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\116\000\078\000\124\000\077\000\125\000\076\000\000\000\
\\069\000\084\000\082\000\083\000\116\000\078\000\124\000\082\000\
\\125\000\076\000\000\000\
\\052\000\012\000\067\000\087\000\070\000\010\000\091\000\086\000\
\\092\000\085\000\094\000\009\000\099\000\008\000\116\000\006\000\
\\121\000\005\000\122\000\004\000\123\000\003\000\126\000\002\000\
\\127\000\001\000\000\000\
\\052\000\012\000\067\000\090\000\070\000\010\000\093\000\089\000\
\\094\000\009\000\099\000\008\000\102\000\088\000\116\000\006\000\
\\121\000\005\000\122\000\004\000\123\000\003\000\126\000\002\000\
\\127\000\001\000\000\000\
\\052\000\012\000\067\000\092\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\053\000\098\000\055\000\097\000\062\000\096\000\
\\100\000\095\000\103\000\094\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\051\000\110\000\061\000\109\000\103\000\108\000\000\000\
\\052\000\012\000\067\000\112\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\110\000\114\000\116\000\006\000\121\000\113\000\000\000\
\\116\000\006\000\121\000\115\000\000\000\
\\109\000\117\000\116\000\069\000\118\000\068\000\000\000\
\\007\000\121\000\023\000\120\000\042\000\119\000\043\000\118\000\
\\115\000\007\000\000\000\
\\065\000\127\000\106\000\126\000\107\000\125\000\114\000\124\000\
\\115\000\123\000\000\000\
\\113\000\130\000\000\000\
\\113\000\132\000\000\000\
\\052\000\012\000\067\000\133\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\055\000\138\000\064\000\137\000\071\000\136\000\
\\101\000\135\000\103\000\134\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\139\000\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\056\000\145\000\116\000\144\000\117\000\143\000\000\000\
\\059\000\150\000\060\000\149\000\103\000\148\000\119\000\147\000\000\000\
\\052\000\012\000\067\000\152\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\051\000\154\000\058\000\153\000\103\000\108\000\000\000\
\\000\000\
\\000\000\
\\022\000\156\000\116\000\155\000\000\000\
\\020\000\158\000\116\000\157\000\000\000\
\\008\000\160\000\116\000\159\000\000\000\
\\116\000\069\000\118\000\161\000\000\000\
\\000\000\
\\047\000\168\000\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\052\000\012\000\067\000\173\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\174\000\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\012\000\067\000\175\000\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\116\000\069\000\118\000\176\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\177\000\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\070\000\179\000\094\000\009\000\116\000\006\000\
\\121\000\005\000\122\000\004\000\123\000\003\000\126\000\002\000\
\\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\098\000\055\000\097\000\062\000\191\000\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\055\000\138\000\101\000\192\000\116\000\006\000\
\\121\000\005\000\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\054\000\199\000\083\000\198\000\116\000\197\000\124\000\196\000\
\\125\000\076\000\000\000\
\\052\000\099\000\053\000\203\000\055\000\097\000\096\000\202\000\
\\097\000\201\000\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\053\000\206\000\055\000\097\000\098\000\205\000\
\\100\000\095\000\104\000\204\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\099\000\053\000\210\000\055\000\097\000\063\000\209\000\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\116\000\006\000\121\000\115\000\000\000\
\\000\000\
\\000\000\
\\119\000\213\000\000\000\
\\104\000\204\000\000\000\
\\000\000\
\\110\000\214\000\116\000\006\000\121\000\113\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\121\000\042\000\215\000\115\000\007\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\217\000\114\000\124\000\115\000\123\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\065\000\219\000\106\000\126\000\107\000\125\000\114\000\124\000\
\\115\000\123\000\000\000\
\\109\000\220\000\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\109\000\221\000\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\052\000\099\000\055\000\138\000\064\000\223\000\071\000\136\000\
\\101\000\135\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\086\000\224\000\000\000\
\\075\000\226\000\000\000\
\\000\000\
\\052\000\099\000\055\000\138\000\101\000\228\000\116\000\006\000\
\\121\000\005\000\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\080\000\229\000\000\000\
\\000\000\
\\052\000\099\000\053\000\206\000\055\000\097\000\098\000\205\000\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\090\000\232\000\000\000\
\\000\000\
\\000\000\
\\116\000\235\000\000\000\
\\000\000\
\\119\000\237\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\119\000\243\000\000\000\
\\025\000\245\000\026\000\244\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\250\000\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\119\000\164\000\120\000\253\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\046\000\003\001\088\000\002\001\116\000\078\000\124\000\001\001\
\\125\000\076\000\000\000\
\\047\000\005\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\105\000\004\001\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\095\000\006\001\000\000\
\\052\000\012\000\067\000\007\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\067\000\087\000\070\000\010\000\092\000\009\001\
\\094\000\009\000\099\000\008\000\116\000\006\000\121\000\005\000\
\\122\000\004\000\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\067\000\012\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\102\000\011\001\116\000\006\000\121\000\005\000\
\\122\000\004\000\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\012\000\067\000\087\000\070\000\010\000\092\000\013\001\
\\094\000\009\000\099\000\008\000\116\000\006\000\121\000\005\000\
\\122\000\004\000\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\052\000\012\000\067\000\014\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\116\000\069\000\118\000\015\001\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\067\000\017\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\047\000\018\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\052\000\099\000\053\000\019\001\055\000\097\000\100\000\095\000\
\\116\000\006\000\121\000\005\000\122\000\093\000\126\000\002\000\
\\127\000\001\000\000\000\
\\000\000\
\\086\000\021\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\210\000\055\000\097\000\063\000\031\001\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\121\000\023\000\033\001\042\000\119\000\043\000\118\000\
\\115\000\007\000\000\000\
\\000\000\
\\052\000\012\000\067\000\035\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\102\000\034\001\116\000\006\000\121\000\005\000\
\\122\000\004\000\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\067\000\037\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\047\000\039\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\052\000\099\000\055\000\138\000\064\000\040\001\071\000\136\000\
\\101\000\135\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\041\001\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\052\000\012\000\067\000\042\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\081\000\043\001\000\000\
\\116\000\006\000\121\000\005\000\122\000\046\001\123\000\045\001\000\000\
\\047\000\047\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\057\000\049\001\116\000\144\000\117\000\048\001\000\000\
\\000\000\
\\051\000\110\000\061\000\052\001\103\000\108\000\000\000\
\\051\000\110\000\061\000\053\001\103\000\108\000\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\054\001\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\051\000\110\000\061\000\055\001\103\000\108\000\000\000\
\\065\000\056\001\106\000\126\000\107\000\125\000\114\000\124\000\
\\115\000\123\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\060\001\116\000\059\001\000\000\
\\021\000\062\001\116\000\059\001\000\000\
\\021\000\063\001\116\000\059\001\000\000\
\\018\000\065\001\116\000\064\001\000\000\
\\000\000\
\\116\000\069\000\118\000\067\001\000\000\
\\116\000\069\001\000\000\
\\000\000\
\\048\000\071\001\049\000\166\000\050\000\165\000\119\000\164\000\
\\120\000\163\000\000\000\
\\116\000\072\001\000\000\
\\047\000\073\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\072\000\079\001\000\000\
\\116\000\069\000\118\000\081\001\000\000\
\\000\000\
\\116\000\069\000\118\000\082\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\083\001\116\000\069\000\118\000\068\000\000\000\
\\073\000\084\001\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\086\001\055\000\097\000\100\000\095\000\
\\116\000\006\000\121\000\005\000\122\000\093\000\126\000\002\000\
\\127\000\001\000\000\000\
\\084\000\087\001\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\203\000\055\000\097\000\097\000\089\001\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\203\000\055\000\097\000\097\000\090\001\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\104\000\091\001\000\000\
\\000\000\
\\000\000\
\\047\000\094\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\065\000\098\001\106\000\126\000\107\000\125\000\114\000\124\000\
\\115\000\123\000\000\000\
\\000\000\
\\052\000\012\000\067\000\100\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\056\000\101\001\116\000\144\000\117\000\143\000\000\000\
\\081\000\102\001\000\000\
\\000\000\
\\000\000\
\\090\000\103\001\000\000\
\\078\000\104\001\000\000\
\\119\000\164\000\120\000\106\001\000\000\
\\057\000\107\001\116\000\144\000\117\000\048\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\057\000\110\001\116\000\144\000\117\000\048\001\000\000\
\\024\000\113\001\116\000\112\001\121\000\111\001\000\000\
\\000\000\
\\000\000\
\\018\000\117\001\000\000\
\\000\000\
\\029\000\118\001\000\000\
\\000\000\
\\019\000\121\001\000\000\
\\000\000\
\\000\000\
\\109\000\132\001\116\000\069\000\118\000\068\000\000\000\
\\116\000\133\001\000\000\
\\116\000\069\000\118\000\137\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\047\000\140\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\119\000\164\000\120\000\142\001\000\000\
\\047\000\144\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\105\000\143\001\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\000\000\
\\069\000\146\001\116\000\078\000\124\000\082\000\125\000\076\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\098\000\055\000\097\000\062\000\148\001\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\085\000\149\001\000\000\
\\085\000\151\001\000\000\
\\052\000\099\000\053\000\152\001\055\000\097\000\100\000\095\000\
\\116\000\006\000\121\000\005\000\122\000\093\000\126\000\002\000\
\\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\154\001\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\077\000\155\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\012\000\067\000\158\001\070\000\010\000\094\000\009\000\
\\099\000\008\000\116\000\006\000\121\000\005\000\122\000\004\000\
\\123\000\003\000\126\000\002\000\127\000\001\000\000\000\
\\076\000\159\001\000\000\
\\000\000\
\\000\000\
\\079\000\161\001\000\000\
\\000\000\
\\051\000\154\000\058\000\163\001\103\000\108\000\000\000\
\\000\000\
\\078\000\164\001\000\000\
\\065\000\165\001\106\000\126\000\107\000\125\000\114\000\124\000\
\\115\000\123\000\000\000\
\\000\000\
\\078\000\166\001\000\000\
\\000\000\
\\000\000\
\\025\000\169\001\028\000\168\001\000\000\
\\007\000\121\000\023\000\171\001\042\000\119\000\043\000\118\000\
\\115\000\007\000\000\000\
\\007\000\121\000\023\000\172\001\042\000\119\000\043\000\118\000\
\\115\000\007\000\000\000\
\\044\000\173\001\000\000\
\\019\000\121\001\000\000\
\\000\000\
\\020\000\176\001\116\000\157\000\000\000\
\\021\000\177\001\116\000\059\001\000\000\
\\000\000\
\\000\000\
\\025\000\245\000\026\000\178\001\000\000\
\\017\000\180\001\116\000\069\000\118\000\179\001\000\000\
\\015\000\184\001\016\000\183\001\035\000\182\001\051\000\181\001\
\\103\000\108\000\000\000\
\\010\000\186\001\116\000\185\001\000\000\
\\013\000\190\001\014\000\189\001\103\000\188\001\119\000\187\001\000\000\
\\009\000\192\001\116\000\191\001\000\000\
\\111\000\194\001\116\000\006\000\121\000\193\001\000\000\
\\021\000\198\001\108\000\197\001\116\000\196\001\000\000\
\\015\000\200\001\051\000\199\001\103\000\108\000\000\000\
\\000\000\
\\000\000\
\\116\000\202\001\000\000\
\\116\000\203\001\000\000\
\\116\000\204\001\000\000\
\\000\000\
\\109\000\205\001\116\000\069\000\118\000\068\000\000\000\
\\047\000\206\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\089\000\207\001\000\000\
\\116\000\069\000\118\000\209\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\116\000\069\000\118\000\211\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\054\000\213\001\116\000\197\000\124\000\196\000\125\000\076\000\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\141\000\055\000\097\000\066\000\140\000\
\\068\000\214\001\100\000\095\000\116\000\006\000\121\000\005\000\
\\122\000\093\000\126\000\002\000\127\000\001\000\000\000\
\\074\000\215\001\000\000\
\\000\000\
\\051\000\110\000\061\000\217\001\103\000\108\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\055\000\138\000\071\000\218\001\101\000\135\000\
\\116\000\006\000\121\000\005\000\122\000\093\000\126\000\002\000\
\\127\000\001\000\000\000\
\\000\000\
\\057\000\219\001\116\000\144\000\117\000\048\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\121\000\023\000\222\001\024\000\221\001\042\000\119\000\
\\043\000\118\000\115\000\007\000\116\000\112\001\121\000\111\001\000\000\
\\000\000\
\\000\000\
\\022\000\223\001\116\000\155\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\051\000\226\001\103\000\108\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\119\000\230\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\090\000\232\001\000\000\
\\000\000\
\\000\000\
\\119\000\234\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\112\000\238\001\119\000\164\000\120\000\237\001\000\000\
\\108\000\240\001\116\000\239\001\000\000\
\\000\000\
\\000\000\
\\119\000\241\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\046\000\243\001\116\000\078\000\124\000\001\001\125\000\076\000\000\000\
\\000\000\
\\116\000\069\000\118\000\244\001\000\000\
\\000\000\
\\109\000\246\001\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\099\000\053\000\210\000\055\000\097\000\063\000\248\001\
\\100\000\095\000\116\000\006\000\121\000\005\000\122\000\093\000\
\\126\000\002\000\127\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\025\000\169\001\000\000\
\\000\000\
\\000\000\
\\024\000\251\001\116\000\112\001\121\000\111\001\000\000\
\\000\000\
\\119\000\164\000\120\000\252\001\000\000\
\\025\000\245\000\026\000\253\001\000\000\
\\024\000\254\001\116\000\112\001\121\000\111\001\000\000\
\\047\000\255\001\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\034\000\000\002\000\000\
\\016\000\183\001\035\000\004\002\051\000\003\002\103\000\108\000\000\000\
\\031\000\005\002\000\000\
\\011\000\008\002\116\000\144\000\117\000\007\002\000\000\
\\000\000\
\\021\000\011\002\116\000\059\001\000\000\
\\111\000\013\002\116\000\006\000\121\000\012\002\000\000\
\\000\000\
\\000\000\
\\108\000\240\001\116\000\239\001\000\000\
\\000\000\
\\034\000\000\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\109\000\015\002\116\000\069\000\118\000\068\000\000\000\
\\000\000\
\\087\000\017\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\025\000\169\001\000\000\
\\000\000\
\\000\000\
\\025\000\169\001\027\000\022\002\000\000\
\\036\000\024\002\000\000\
\\000\000\
\\047\000\026\002\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\015\000\027\002\051\000\199\001\103\000\108\000\000\000\
\\119\000\028\002\000\000\
\\000\000\
\\000\000\
\\010\000\029\002\116\000\185\001\000\000\
\\090\000\030\002\000\000\
\\033\000\031\002\000\000\
\\119\000\164\000\120\000\033\002\000\000\
\\011\000\034\002\116\000\144\000\117\000\007\002\000\000\
\\030\000\035\002\000\000\
\\000\000\
\\000\000\
\\112\000\038\002\119\000\164\000\120\000\037\002\000\000\
\\000\000\
\\000\000\
\\074\000\040\002\000\000\
\\047\000\041\002\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\000\000\
\\047\000\042\002\048\000\167\000\049\000\166\000\050\000\165\000\
\\119\000\164\000\120\000\163\000\000\000\
\\024\000\043\002\116\000\112\001\121\000\111\001\000\000\
\\000\000\
\\008\000\044\002\116\000\159\000\000\000\
\\000\000\
\\017\000\045\002\116\000\069\000\118\000\179\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\046\002\000\000\
\\000\000\
\\012\000\049\002\051\000\048\002\103\000\108\000\000\000\
\\000\000\
\\033\000\050\002\000\000\
\\000\000\
\\009\000\051\002\116\000\191\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\087\000\052\002\000\000\
\\045\000\053\002\000\000\
\\025\000\169\001\027\000\055\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\056\002\116\000\144\000\117\000\007\002\000\000\
\\119\000\057\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\058\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\060\002\116\000\144\000\117\000\007\002\000\000\
\\033\000\061\002\000\000\
\\000\000\
\\000\000\
\"
val numstates = 575
val numrules = 310
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = LexBasics.pos
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | TYVAR of unit ->  (string) | ID of unit ->  (string)
 | AQID of unit ->  (string) | OBJL of unit ->  (string)
 | ENDQ of unit ->  (string) | STRING of unit ->  (string)
 | REAL of unit ->  (string option)
 | WORD of unit ->  (IntInf.int option) | DIGIT of unit ->  (int)
 | HEXINTEGER of unit ->  (IntInf.int option)
 | DECNEGINTEGER of unit ->  (IntInf.int option)
 | DECPOSINTEGER of unit ->  (IntInf.int option)
 | QUAL_STAR of unit ->  (string list)
 | QUAL_ID of unit ->  (string list) | Char of unit ->  (int)
 | Integer of unit ->  (IntInf.int)
 | DecPosInteger of unit ->  (IntInf.int) | Label of unit ->  (lab)
 | LongOpEqIdent of unit ->  (string list op_opt)
 | LongOpIdent of unit ->  (string list op_opt)
 | LongIdent of unit ->  (string list)
 | LongTypeIdent of unit ->  (string list)
 | TypeIdent of unit ->  (string) | EqIdent of unit ->  (string)
 | OpIdent of unit ->  (string op_opt) | Ident of unit ->  (string)
 | OneDec_sans_LOCAL of unit ->  (dec) | OneDec of unit ->  (dec)
 | DIGIT_opt of unit ->  (int option)
 | LongTypeIdentEq_seq2 of unit ->  (string list WithInfo list)
 | LongIdentEq_seq2 of unit ->  (string list WithInfo list)
 | LongIdent_seq1 of unit ->  (string list WithInfo list)
 | EqIdent_seq1 of unit ->  (string list)
 | Ident_seq2 of unit ->  (string WithInfo list)
 | NonEmptyDec of unit ->  (dec)
 | OneDec_or_SEMICOLON of unit ->  (dec option)
 | TyComma_seq2 of unit ->  (ty list)
 | TyVarComma_seq1 of unit ->  (tyvar list)
 | TyVarSeq1 of unit ->  (tyvar list)
 | ExpSemicolon_seq2 of unit ->  (exp list)
 | AtPat_seq1 of unit ->  (atpat list)
 | AtPat_seq2 of unit ->  (atpat list)
 | AtExp_seq1 of unit ->  (atexp list)
 | PatComma_seq2 of unit ->  (pat list)
 | PatComma_seq1 of unit ->  (pat list)
 | PatComma_seq0 of unit ->  (pat list)
 | OtList of unit ->  (exp list) | Quote of unit ->  (exp list)
 | ExpComma_seq2 of unit ->  (exp list)
 | ExpComma_seq1 of unit ->  (exp list)
 | ExpComma_seq0 of unit ->  (exp list)
 | OfTy_opt of unit ->  (ty option)
 | CommaTyRow_opt of unit ->  (tyrow option)
 | TyRow_opt of unit ->  (tyrow option)
 | ColonTy_seq1 of unit ->  ( ( ty * pos )  list)
 | ColonTy_opt of unit ->  (ty option)
 | CommaPatRow_opt of unit ->  (patrow option)
 | AsPat_opt of unit ->  (pat option)
 | PatRow_opt of unit ->  (patrow option)
 | ExpRow_opt of unit ->  (exprow option)
 | AndExBind_opt of unit ->  (exbind option)
 | BarMatch_opt of unit ->  (match option)
 | BarConBind_opt of unit ->  (conbind option)
 | AndDatBind_opt of unit ->  (datbind option)
 | AndTypBind_opt of unit ->  (typbind option)
 | BarFClause_opt of unit ->  (FClause option)
 | AndFValBind_opt of unit ->  (FValBind option)
 | AndFnValBind_opt of unit ->  (valbind option)
 | AndValBind_opt of unit ->  (valbind option)
 | CommaExpRow_opt of unit ->  (exprow option)
 | FClause of unit ->  (FClause) | AtExp of unit ->  (atexp)
 | ExpRow of unit ->  (exprow) | Match_ of unit ->  (match)
 | Exp_ of unit ->  (exp) | MRule of unit ->  (mrule)
 | Dec of unit ->  (dec) | FValBind of unit ->  (FValBind)
 | FnValBind of unit ->  (valbind) | ValBind of unit ->  (valbind)
 | TypBind of unit ->  (typbind)
 | DatBind_nonzero_arity of unit ->  (datbind)
 | DatBind_zero_arity of unit ->  (datbind)
 | DatBind of unit ->  (datbind) | ConBind of unit ->  (conbind)
 | ExBind of unit ->  (exbind) | AtPat of unit ->  (atpat)
 | PatRow of unit ->  (patrow) | Pat of unit ->  (pat)
 | SCon of unit ->  (scon) | TyVarSeq of unit ->  (tyvar list)
 | AtomicTy of unit ->  (ty) | Ty_sans_STAR of unit ->  (ty)
 | TupleTy of unit ->  (ty list) | Ty of unit ->  (ty)
 | TyRow of unit ->  (tyrow)
 | AndWhereDesc_opt of unit ->  ( ( pos * sigexp -> sigexp )  option)
 | WhereDesc of unit ->  (pos*sigexp -> sigexp)
 | NonEmptyStrDec of unit ->  (strdec)
 | OneStrDec_or_SEMICOLON of unit ->  (strdec option)
 | NonEmptySpec' of unit ->  (spec)
 | Spec_sans_SHARING of unit ->  (spec)
 | NonEmptySpec of unit ->  (spec)
 | OneSpec_or_SEMICOLON of unit ->  (spec option)
 | SEMICOLON_opt of unit ->  (unit)
 | AndValDesc_opt of unit ->  (valdesc option)
 | TypAbbreviationAND_seq1 of unit ->  ( ( tyvar list * tycon * ty * info * info )  list)
 | AndTypDesc_opt of unit ->  (typdesc option)
 | AndDatDesc_opt of unit ->  (datdesc option)
 | BarConDesc_opt of unit ->  (condesc option)
 | AndExDesc_opt of unit ->  (exdesc option)
 | AndStrDesc_opt of unit ->  (strdesc option)
 | AndSigBind_opt of unit ->  (sigbind option)
 | AndStrBind_opt of unit ->  (strbind option)
 | AndFunBind_opt of unit ->  (funbind option)
 | SigExp_constraint_maybe of unit ->  (pos -> strexp -> strexp)
 | SigExp_constraint of unit ->  (pos -> strexp -> strexp)
 | StrExp of unit ->  (strexp) | StrDec of unit ->  (strdec)
 | StrBind of unit ->  (strbind) | SigExp of unit ->  (sigexp)
 | SigBind of unit ->  (sigbind) | OneSpec of unit ->  (spec)
 | Spec of unit ->  (spec) | ValDesc of unit ->  (valdesc)
 | TypAbbreviation of unit ->  (tyvar list*tycon*ty*info*info)
 | TypDesc of unit ->  (typdesc)
 | DatDesc_nonzero_arity of unit ->  (datdesc)
 | DatDesc_zero_arity of unit ->  (datdesc)
 | DatDesc of unit ->  (datdesc) | ConDesc of unit ->  (condesc)
 | ExDesc of unit ->  (exdesc) | StrDesc of unit ->  (strdesc)
 | FunBind of unit ->  (funbind) | OneStrDec of unit ->  (strdec)
 | FunDec of unit ->  (fundec)
 | StrDec_sans_SEMICOLON of unit ->  (strdec)
 | SigDec of unit ->  (sigdec)
 | TopDec_opt of unit ->  (topdec option)
 | TopDec_ of unit ->  (topdec) | TopDec of unit ->  (topdec)
end
type svalue = MlyValue.svalue
type result = topdec
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn (T 0) => true | (T 1) => true | (T 2) => true | (T 3) => true | (T 
4) => true | (T 5) => true | (T 6) => true | (T 7) => true | (T 12)
 => true | (T 13) => true | (T 14) => true | (T 15) => true | (T 16)
 => true | (T 17) => true | (T 18) => true | (T 19) => true | (T 20)
 => true | (T 21) => true | (T 22) => true | (T 23) => true | (T 24)
 => true | (T 25) => true | (T 26) => true | (T 27) => true | (T 28)
 => true | (T 29) => true | (T 30) => true | (T 31) => true | (T 32)
 => true | (T 33) => true | (T 34) => true | (T 35) => true | (T 36)
 => true | (T 37) => true | (T 38) => true | (T 39) => true | (T 40)
 => true | (T 10) => true | (T 41) => true | (T 42) => true | (T 43)
 => true | _ => false
val preferred_change : (term list * term list) list = 
nil
val noShift = 
fn (T 77) => true | _ => false
val showTerminal =
fn (T 0) => "EQTYPE"
  | (T 1) => "FUNCTOR"
  | (T 2) => "INCLUDE"
  | (T 3) => "SHARING"
  | (T 4) => "SIG"
  | (T 5) => "SIGNATURE"
  | (T 6) => "STRUCT"
  | (T 7) => "STRUCTURE"
  | (T 8) => "QUAL_ID"
  | (T 9) => "QUAL_STAR"
  | (T 10) => "WHERE"
  | (T 11) => "COLONGREATER"
  | (T 12) => "ABSTYPE"
  | (T 13) => "AND"
  | (T 14) => "ANDALSO"
  | (T 15) => "AS"
  | (T 16) => "CASE"
  | (T 17) => "DO"
  | (T 18) => "DATATYPE"
  | (T 19) => "ELSE"
  | (T 20) => "END"
  | (T 21) => "EXCEPTION"
  | (T 22) => "FN"
  | (T 23) => "FUN"
  | (T 24) => "HANDLE"
  | (T 25) => "IF"
  | (T 26) => "IN"
  | (T 27) => "INFIX"
  | (T 28) => "INFIXR"
  | (T 29) => "LET"
  | (T 30) => "LOCAL"
  | (T 31) => "NONFIX"
  | (T 32) => "OF"
  | (T 33) => "OP"
  | (T 34) => "OPEN"
  | (T 35) => "ORELSE"
  | (T 36) => "RAISE"
  | (T 37) => "REC"
  | (T 38) => "THEN"
  | (T 39) => "TYPE"
  | (T 40) => "VAL"
  | (T 41) => "WITH"
  | (T 42) => "WITHTYPE"
  | (T 43) => "WHILE"
  | (T 44) => "LPAREN"
  | (T 45) => "RPAREN"
  | (T 46) => "LBRACKET"
  | (T 47) => "RBRACKET"
  | (T 48) => "LBRACE"
  | (T 49) => "RBRACE"
  | (T 50) => "COMMA"
  | (T 51) => "COLON"
  | (T 52) => "SEMICOLON"
  | (T 53) => "DOTDOTDOT"
  | (T 54) => "UNDERBAR"
  | (T 55) => "BAR"
  | (T 56) => "DARROW"
  | (T 57) => "ARROW"
  | (T 58) => "HASH"
  | (T 59) => "EQUALS"
  | (T 60) => "STAR"
  | (T 61) => "HASHHASH"
  | (T 62) => "DECPOSINTEGER"
  | (T 63) => "DECNEGINTEGER"
  | (T 64) => "HEXINTEGER"
  | (T 65) => "DIGIT"
  | (T 66) => "WORD"
  | (T 67) => "REAL"
  | (T 68) => "STRING"
  | (T 69) => "BEGINQ"
  | (T 70) => "ENDQ"
  | (T 71) => "OBJL"
  | (T 72) => "AQID"
  | (T 73) => "ID"
  | (T 74) => "TYVAR"
  | (T 75) => "BACKQUOTE"
  | (T 76) => "REGION"
  | (T 77) => "EOF"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn (T 8) => MlyValue.QUAL_ID(fn () => (["bogus"])) | 
(T 9) => MlyValue.QUAL_STAR(fn () => (["bogus"])) | 
(T 62) => MlyValue.DECPOSINTEGER(fn () => (SOME (IntInf.fromInt 0))) | 
(T 63) => MlyValue.DECNEGINTEGER(fn () => (SOME (IntInf.fromInt 0))) | 
(T 64) => MlyValue.HEXINTEGER(fn () => (SOME (IntInf.fromInt 0))) | 
(T 66) => MlyValue.WORD(fn () => (SOME 0)) | 
(T 67) => MlyValue.REAL(fn () => (SOME "0.0")) | 
(T 68) => MlyValue.STRING(fn () => ("")) | 
(T 73) => MlyValue.ID(fn () => ("bogus")) | 
(T 74) => MlyValue.TYVAR(fn () => ("'bogus")) | 
(T 65) => MlyValue.DIGIT(fn () => (0)) | 
_ => MlyValue.VOID
end
val terms : term list = nil
 $$ (T 77) $$ (T 76) $$ (T 75) $$ (T 69) $$ (T 61) $$ (T 60) $$ (T 59)
 $$ (T 58) $$ (T 57) $$ (T 56) $$ (T 55) $$ (T 54) $$ (T 53) $$ (T 52)
 $$ (T 51) $$ (T 50) $$ (T 49) $$ (T 48) $$ (T 47) $$ (T 46) $$ (T 45)
 $$ (T 44) $$ (T 43) $$ (T 42) $$ (T 41) $$ (T 40) $$ (T 39) $$ (T 38)
 $$ (T 37) $$ (T 36) $$ (T 35) $$ (T 34) $$ (T 33) $$ (T 32) $$ (T 31)
 $$ (T 30) $$ (T 29) $$ (T 28) $$ (T 27) $$ (T 26) $$ (T 25) $$ (T 24)
 $$ (T 23) $$ (T 22) $$ (T 21) $$ (T 20) $$ (T 19) $$ (T 18) $$ (T 17)
 $$ (T 16) $$ (T 15) $$ (T 14) $$ (T 13) $$ (T 12) $$ (T 11) $$ (T 10)
 $$ (T 7) $$ (T 6) $$ (T 5) $$ (T 4) $$ (T 3) $$ (T 2) $$ (T 1) $$ (T 
0)end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.Ident (fn _ => let val  (ID as ID1) = ID1
 ()
 in ( ID )
end)
 in ( LrTable.NT 115, ( result, ID1left, ID1right), rest671)
end
|  ( 1, ( ( _, ( _, STAR1left, STAR1right)) :: rest671)) => let val  
result = MlyValue.Ident (fn _ => ( "*" ))
 in ( LrTable.NT 115, ( result, STAR1left, STAR1right), rest671)
end
|  ( 2, ( ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: 
rest671)) => let val  result = MlyValue.OpIdent (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 in ( OP_OPT(Ident, false) )
end)
 in ( LrTable.NT 116, ( result, Ident1left, Ident1right), rest671)
end
|  ( 3, ( ( _, ( MlyValue.Ident Ident1, _, Ident1right)) :: ( _, ( _, 
OP1left, _)) :: rest671)) => let val  result = MlyValue.OpIdent (fn _
 => let val  (Ident as Ident1) = Ident1 ()
 in ( OP_OPT(Ident, true) )
end)
 in ( LrTable.NT 116, ( result, OP1left, Ident1right), rest671)
end
|  ( 4, ( ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: 
rest671)) => let val  result = MlyValue.EqIdent (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 in ( Ident )
end)
 in ( LrTable.NT 117, ( result, Ident1left, Ident1right), rest671)
end
|  ( 5, ( ( _, ( _, EQUALS1left, EQUALS1right)) :: rest671)) => let
 val  result = MlyValue.EqIdent (fn _ => ( "=" ))
 in ( LrTable.NT 117, ( result, EQUALS1left, EQUALS1right), rest671)

end
|  ( 6, ( ( _, ( _, HASHHASH1left, HASHHASH1right)) :: rest671)) =>
 let val  result = MlyValue.EqIdent (fn _ => ( "##" ))
 in ( LrTable.NT 117, ( result, HASHHASH1left, HASHHASH1right), 
rest671)
end
|  ( 7, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.TypeIdent (fn _ => let val  (ID as ID1) = 
ID1 ()
 in ( ID )
end)
 in ( LrTable.NT 118, ( result, ID1left, ID1right), rest671)
end
|  ( 8, ( ( _, ( MlyValue.TypeIdent TypeIdent1, TypeIdent1left, 
TypeIdent1right)) :: rest671)) => let val  result = 
MlyValue.LongTypeIdent (fn _ => let val  (TypeIdent as TypeIdent1) = 
TypeIdent1 ()
 in ( [TypeIdent] )
end)
 in ( LrTable.NT 119, ( result, TypeIdent1left, TypeIdent1right), 
rest671)
end
|  ( 9, ( ( _, ( MlyValue.QUAL_ID QUAL_ID1, QUAL_ID1left, 
QUAL_ID1right)) :: rest671)) => let val  result = 
MlyValue.LongTypeIdent (fn _ => let val  (QUAL_ID as QUAL_ID1) = 
QUAL_ID1 ()
 in ( QUAL_ID )
end)
 in ( LrTable.NT 119, ( result, QUAL_ID1left, QUAL_ID1right), rest671)

end
|  ( 10, ( ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: 
rest671)) => let val  result = MlyValue.LongIdent (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 in ( [Ident] )
end)
 in ( LrTable.NT 120, ( result, Ident1left, Ident1right), rest671)
end
|  ( 11, ( ( _, ( MlyValue.QUAL_ID QUAL_ID1, QUAL_ID1left, 
QUAL_ID1right)) :: rest671)) => let val  result = MlyValue.LongIdent
 (fn _ => let val  (QUAL_ID as QUAL_ID1) = QUAL_ID1 ()
 in ( QUAL_ID )
end)
 in ( LrTable.NT 120, ( result, QUAL_ID1left, QUAL_ID1right), rest671)

end
|  ( 12, ( ( _, ( MlyValue.QUAL_STAR QUAL_STAR1, QUAL_STAR1left, 
QUAL_STAR1right)) :: rest671)) => let val  result = MlyValue.LongIdent
 (fn _ => let val  (QUAL_STAR as QUAL_STAR1) = QUAL_STAR1 ()
 in ( QUAL_STAR )
end)
 in ( LrTable.NT 120, ( result, QUAL_STAR1left, QUAL_STAR1right), 
rest671)
end
|  ( 13, ( ( _, ( MlyValue.LongIdent LongIdent1, LongIdent1left, 
LongIdent1right)) :: rest671)) => let val  result = 
MlyValue.LongOpIdent (fn _ => let val  (LongIdent as LongIdent1) = 
LongIdent1 ()
 in ( OP_OPT(LongIdent, false) )
end)
 in ( LrTable.NT 121, ( result, LongIdent1left, LongIdent1right), 
rest671)
end
|  ( 14, ( ( _, ( MlyValue.LongIdent LongIdent1, _, LongIdent1right))
 :: ( _, ( _, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.LongOpIdent (fn _ => let val  (LongIdent as LongIdent1) = 
LongIdent1 ()
 in ( OP_OPT(LongIdent, true) )
end)
 in ( LrTable.NT 121, ( result, OP1left, LongIdent1right), rest671)

end
|  ( 15, ( ( _, ( MlyValue.LongOpIdent LongOpIdent1, LongOpIdent1left,
 LongOpIdent1right)) :: rest671)) => let val  result = 
MlyValue.LongOpEqIdent (fn _ => let val  (LongOpIdent as LongOpIdent1)
 = LongOpIdent1 ()
 in ( LongOpIdent )
end)
 in ( LrTable.NT 122, ( result, LongOpIdent1left, LongOpIdent1right), 
rest671)
end
|  ( 16, ( ( _, ( _, EQUALS1left, EQUALS1right)) :: rest671)) => let
 val  result = MlyValue.LongOpEqIdent (fn _ => ( OP_OPT(["="], false) 
))
 in ( LrTable.NT 122, ( result, EQUALS1left, EQUALS1right), rest671)

end
|  ( 17, ( ( _, ( _, _, EQUALS1right)) :: ( _, ( _, OP1left, _)) :: 
rest671)) => let val  result = MlyValue.LongOpEqIdent (fn _ => (
 OP_OPT(["="], true) ))
 in ( LrTable.NT 122, ( result, OP1left, EQUALS1right), rest671)
end
|  ( 18, ( ( _, ( MlyValue.DIGIT DIGIT1, DIGIT1left, DIGIT1right)) :: 
rest671)) => let val  result = MlyValue.DIGIT_opt (fn _ => let val  (
DIGIT as DIGIT1) = DIGIT1 ()
 in ( SOME DIGIT )
end)
 in ( LrTable.NT 112, ( result, DIGIT1left, DIGIT1right), rest671)
end
|  ( 19, ( rest671)) => let val  result = MlyValue.DIGIT_opt (fn _ =>
 ( NONE ))
 in ( LrTable.NT 112, ( result, defaultPos, defaultPos), rest671)
end
|  ( 20, ( ( _, ( MlyValue.DECPOSINTEGER DECPOSINTEGER1, (
DECPOSINTEGERleft as DECPOSINTEGER1left), DECPOSINTEGER1right)) :: 
rest671)) => let val  result = MlyValue.DecPosInteger (fn _ => let
 val  (DECPOSINTEGER as DECPOSINTEGER1) = DECPOSINTEGER1 ()
 in (
 raise_lexical_error_if_none
			    DECPOSINTEGERleft DECPOSINTEGER )

end)
 in ( LrTable.NT 124, ( result, DECPOSINTEGER1left, 
DECPOSINTEGER1right), rest671)
end
|  ( 21, ( ( _, ( MlyValue.DIGIT DIGIT1, DIGIT1left, DIGIT1right)) :: 
rest671)) => let val  result = MlyValue.DecPosInteger (fn _ => let
 val  (DIGIT as DIGIT1) = DIGIT1 ()
 in ( IntInf.fromInt DIGIT )
end)
 in ( LrTable.NT 124, ( result, DIGIT1left, DIGIT1right), rest671)
end
|  ( 22, ( ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: 
rest671)) => let val  result = MlyValue.Label (fn _ => let val  (Ident
 as Ident1) = Ident1 ()
 in ( mk_IdentLab Ident )
end)
 in ( LrTable.NT 123, ( result, Ident1left, Ident1right), rest671)
end
|  ( 23, ( ( _, ( MlyValue.DecPosInteger DecPosInteger1, 
DecPosInteger1left, DecPosInteger1right)) :: rest671)) => let val  
result = MlyValue.Label (fn _ => let val  (DecPosInteger as 
DecPosInteger1) = DecPosInteger1 ()
 in ( mk_IntegerLab (IntInf.toInt DecPosInteger) )
end)
 in ( LrTable.NT 123, ( result, DecPosInteger1left, 
DecPosInteger1right), rest671)
end
|  ( 24, ( ( _, ( MlyValue.Ident_seq2 Ident_seq21, _, Ident_seq21right
)) :: ( _, ( MlyValue.Ident Ident1, (Identleft as Ident1left), 
Identright)) :: rest671)) => let val  result = MlyValue.Ident_seq2 (fn
 _ => let val  (Ident as Ident1) = Ident1 ()
 val  (Ident_seq2 as Ident_seq21) = Ident_seq21 ()
 in (
 WITH_INFO(PP Identleft Identright, Ident)
                          :: Ident_seq2
                        
)
end)
 in ( LrTable.NT 107, ( result, Ident1left, Ident_seq21right), rest671
)
end
|  ( 25, ( ( _, ( MlyValue.Ident Ident2, Ident2left, Ident2right)) :: 
( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: rest671))
 => let val  result = MlyValue.Ident_seq2 (fn _ => let val  Ident1 = 
Ident1 ()
 val  Ident2 = Ident2 ()
 in (
 [WITH_INFO(PP Ident1left Ident1right, Ident1),
			   WITH_INFO(PP Ident2left Ident2right, Ident2)] 
)
end)
 in ( LrTable.NT 107, ( result, Ident1left, Ident2right), rest671)
end
|  ( 26, ( ( _, ( MlyValue.EqIdent_seq1 EqIdent_seq11, _, 
EqIdent_seq11right)) :: ( _, ( MlyValue.EqIdent EqIdent1, EqIdent1left
, _)) :: rest671)) => let val  result = MlyValue.EqIdent_seq1 (fn _ =>
 let val  (EqIdent as EqIdent1) = EqIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in ( EqIdent :: EqIdent_seq1 )
end)
 in ( LrTable.NT 108, ( result, EqIdent1left, EqIdent_seq11right), 
rest671)
end
|  ( 27, ( ( _, ( MlyValue.EqIdent EqIdent1, EqIdent1left, 
EqIdent1right)) :: rest671)) => let val  result = 
MlyValue.EqIdent_seq1 (fn _ => let val  (EqIdent as EqIdent1) = 
EqIdent1 ()
 in ( [EqIdent] )
end)
 in ( LrTable.NT 108, ( result, EqIdent1left, EqIdent1right), rest671)

end
|  ( 28, ( ( _, ( MlyValue.LongIdent_seq1 LongIdent_seq11, _, 
LongIdent_seq11right)) :: ( _, ( MlyValue.LongIdent LongIdent1, (
LongIdentleft as LongIdent1left), LongIdentright)) :: rest671)) => let
 val  result = MlyValue.LongIdent_seq1 (fn _ => let val  (LongIdent
 as LongIdent1) = LongIdent1 ()
 val  (LongIdent_seq1 as LongIdent_seq11) = LongIdent_seq11 ()
 in (
 WITH_INFO(PP LongIdentleft LongIdentright,
                                    LongIdent
                                   ) :: LongIdent_seq1
                        
)
end)
 in ( LrTable.NT 109, ( result, LongIdent1left, LongIdent_seq11right),
 rest671)
end
|  ( 29, ( ( _, ( MlyValue.LongIdent LongIdent1, (LongIdentleft as 
LongIdent1left), (LongIdentright as LongIdent1right))) :: rest671)) =>
 let val  result = MlyValue.LongIdent_seq1 (fn _ => let val  (
LongIdent as LongIdent1) = LongIdent1 ()
 in (
 [WITH_INFO(PP LongIdentleft LongIdentright,
                                     LongIdent
                                    )
                          ]
                        
)
end)
 in ( LrTable.NT 109, ( result, LongIdent1left, LongIdent1right), 
rest671)
end
|  ( 30, ( ( _, ( MlyValue.LongIdentEq_seq2 LongIdentEq_seq21, _, 
LongIdentEq_seq21right)) :: _ :: ( _, ( MlyValue.LongIdent LongIdent1,
 (LongIdentleft as LongIdent1left), LongIdentright)) :: rest671)) =>
 let val  result = MlyValue.LongIdentEq_seq2 (fn _ => let val  (
LongIdent as LongIdent1) = LongIdent1 ()
 val  (LongIdentEq_seq2 as LongIdentEq_seq21) = LongIdentEq_seq21 ()
 in (
 WITH_INFO(PP LongIdentleft LongIdentright, LongIdent)
                          :: LongIdentEq_seq2
                        
)
end)
 in ( LrTable.NT 110, ( result, LongIdent1left, LongIdentEq_seq21right
), rest671)
end
|  ( 31, ( ( _, ( MlyValue.LongIdent LongIdent2, LongIdent2left, 
LongIdent2right)) :: _ :: ( _, ( MlyValue.LongIdent LongIdent1, 
LongIdent1left, LongIdent1right)) :: rest671)) => let val  result = 
MlyValue.LongIdentEq_seq2 (fn _ => let val  LongIdent1 = LongIdent1 ()
 val  LongIdent2 = LongIdent2 ()
 in (
 [WITH_INFO(PP LongIdent1left LongIdent1right,
                                     LongIdent1
                                    ),
                           WITH_INFO(PP LongIdent2left LongIdent2right,
                                     LongIdent2
                                    )
                          ]
                        
)
end)
 in ( LrTable.NT 110, ( result, LongIdent1left, LongIdent2right), 
rest671)
end
|  ( 32, ( ( _, ( MlyValue.LongTypeIdentEq_seq2 LongTypeIdentEq_seq21,
 _, LongTypeIdentEq_seq21right)) :: _ :: ( _, ( MlyValue.LongTypeIdent
 LongTypeIdent1, (LongTypeIdentleft as LongTypeIdent1left), 
LongTypeIdentright)) :: rest671)) => let val  result = 
MlyValue.LongTypeIdentEq_seq2 (fn _ => let val  (LongTypeIdent as 
LongTypeIdent1) = LongTypeIdent1 ()
 val  (LongTypeIdentEq_seq2 as LongTypeIdentEq_seq21) = 
LongTypeIdentEq_seq21 ()
 in (
 WITH_INFO(PP LongTypeIdentleft LongTypeIdentright,
                                    LongTypeIdent
                                   )
                          :: LongTypeIdentEq_seq2
                        
)
end)
 in ( LrTable.NT 111, ( result, LongTypeIdent1left, 
LongTypeIdentEq_seq21right), rest671)
end
|  ( 33, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent2, 
LongTypeIdent2left, LongTypeIdent2right)) :: _ :: ( _, ( 
MlyValue.LongTypeIdent LongTypeIdent1, LongTypeIdent1left, 
LongTypeIdent1right)) :: rest671)) => let val  result = 
MlyValue.LongTypeIdentEq_seq2 (fn _ => let val  LongTypeIdent1 = 
LongTypeIdent1 ()
 val  LongTypeIdent2 = LongTypeIdent2 ()
 in (
 [WITH_INFO(PP LongTypeIdent1left LongTypeIdent1right,
                                     LongTypeIdent1
                                    ),
                           WITH_INFO(PP LongTypeIdent2left LongTypeIdent2right,
                                     LongTypeIdent2
                                    )
                          ]
                        
)
end)
 in ( LrTable.NT 111, ( result, LongTypeIdent1left, 
LongTypeIdent2right), rest671)
end
|  ( 34, ( ( _, ( MlyValue.TopDec_ TopDec_1, TopDec_1left, 
TopDec_1right)) :: rest671)) => let val  result = MlyValue.TopDec (fn
 _ => let val  (TopDec_ as TopDec_1) = TopDec_1 ()
 in ( TopDec_ )
end)
 in ( LrTable.NT 0, ( result, TopDec_1left, TopDec_1right), rest671)

end
|  ( 35, ( ( _, ( MlyValue.Exp_ Exp_1, Exp_1left, Exp_1right)) :: 
rest671)) => let val  result = MlyValue.TopDec (fn _ => let val  (Exp_
 as Exp_1) = Exp_1 ()
 in ( topdecOfExp Exp_ )
end)
 in ( LrTable.NT 0, ( result, Exp_1left, Exp_1right), rest671)
end
|  ( 36, ( rest671)) => let val  result = MlyValue.TopDec (fn _ => (
 STRtopdec(PP defaultPos defaultPos,
				    EMPTYstrdec(PP defaultPos defaultPos), NONE) 
))
 in ( LrTable.NT 0, ( result, defaultPos, defaultPos), rest671)
end
|  ( 37, ( ( _, ( MlyValue.TopDec_opt TopDec_opt1, _, TopDec_opt1right
)) :: ( _, ( MlyValue.OneStrDec OneStrDec1, (OneStrDecleft as 
OneStrDec1left), _)) :: rest671)) => let val  result = 
MlyValue.TopDec_ (fn _ => let val  (OneStrDec as OneStrDec1) = 
OneStrDec1 ()
 val  (TopDec_opt as TopDec_opt1) = TopDec_opt1 ()
 in (
 STRtopdec (PP OneStrDecleft
				       (rightmost info_on_strdec OneStrDec
				                  info_on_topdec TopDec_opt),
				     OneStrDec, TopDec_opt) 
)
end)
 in ( LrTable.NT 1, ( result, OneStrDec1left, TopDec_opt1right), 
rest671)
end
|  ( 38, ( ( _, ( MlyValue.TopDec_opt TopDec_opt1, _, TopDec_opt1right
)) :: ( _, ( MlyValue.SigDec SigDec1, (SigDecleft as SigDec1left), _))
 :: rest671)) => let val  result = MlyValue.TopDec_ (fn _ => let val 
 (SigDec as SigDec1) = SigDec1 ()
 val  (TopDec_opt as TopDec_opt1) = TopDec_opt1 ()
 in (
 SIGtopdec (PP SigDecleft
				       (rightmost info_on_sigdec SigDec
				                  info_on_topdec TopDec_opt),
				     SigDec, TopDec_opt) 
)
end)
 in ( LrTable.NT 1, ( result, SigDec1left, TopDec_opt1right), rest671)

end
|  ( 39, ( ( _, ( MlyValue.TopDec_opt TopDec_opt1, _, TopDec_opt1right
)) :: ( _, ( MlyValue.FunDec FunDec1, (FunDecleft as FunDec1left), _))
 :: rest671)) => let val  result = MlyValue.TopDec_ (fn _ => let val 
 (FunDec as FunDec1) = FunDec1 ()
 val  (TopDec_opt as TopDec_opt1) = TopDec_opt1 ()
 in (
 FUNtopdec (PP FunDecleft
				       (rightmost info_on_fundec FunDec
				                  info_on_topdec TopDec_opt),
				     FunDec, TopDec_opt) 
)
end)
 in ( LrTable.NT 1, ( result, FunDec1left, TopDec_opt1right), rest671)

end
|  ( 40, ( ( _, ( MlyValue.TopDec_ TopDec_1, TopDec_1left, 
TopDec_1right)) :: rest671)) => let val  result = MlyValue.TopDec_opt
 (fn _ => let val  (TopDec_ as TopDec_1) = TopDec_1 ()
 in ( SOME TopDec_ )
end)
 in ( LrTable.NT 2, ( result, TopDec_1left, TopDec_1right), rest671)

end
|  ( 41, ( rest671)) => let val  result = MlyValue.TopDec_opt (fn _ =>
 ( NONE ))
 in ( LrTable.NT 2, ( result, defaultPos, defaultPos), rest671)
end
|  ( 42, ( ( _, ( MlyValue.AndFunBind_opt AndFunBind_opt1, _, 
AndFunBind_opt1right)) :: ( _, ( MlyValue.StrExp StrExp1, _, 
StrExpright)) :: _ :: ( _, ( MlyValue.SigExp_constraint_maybe 
SigExp_constraint_maybe1, SigExp_constraint_maybeleft, _)) :: _ :: ( _
, ( MlyValue.SigExp SigExp1, _, _)) :: _ :: ( _, ( MlyValue.Ident 
Ident2, _, _)) :: _ :: ( _, ( MlyValue.Ident Ident1, Ident1left, _))
 :: rest671)) => let val  result = MlyValue.FunBind (fn _ => let val  
Ident1 = Ident1 ()
 val  Ident2 = Ident2 ()
 val  (SigExp as SigExp1) = SigExp1 ()
 val  (SigExp_constraint_maybe as SigExp_constraint_maybe1) = 
SigExp_constraint_maybe1 ()
 val  (StrExp as StrExp1) = StrExp1 ()
 val  (AndFunBind_opt as AndFunBind_opt1) = AndFunBind_opt1 ()
 in (
 let val i_body = PP SigExp_constraint_maybeleft StrExpright
                              val empty_strdec = EMPTYstrdec (PP defaultPos defaultPos)
                          in
                             FUNBIND (PP Ident1left
				     (rightmost info_on_strexp StrExp
				                info_on_funbind AndFunBind_opt),
                                   mk_FunId Ident1, mk_StrId Ident2, SigExp,
                                   LETstrexp(i_body, empty_strdec,
                                             SigExp_constraint_maybe SigExp_constraint_maybeleft StrExp),
                                   AndFunBind_opt)
                          end 
)
end)
 in ( LrTable.NT 7, ( result, Ident1left, AndFunBind_opt1right), 
rest671)
end
|  ( 43, ( ( _, ( MlyValue.AndFunBind_opt AndFunBind_opt1, _, 
AndFunBind_opt1right)) :: ( _, ( MlyValue.StrExp StrExp1, _, 
StrExpright)) :: _ :: ( _, ( MlyValue.SigExp_constraint_maybe 
SigExp_constraint_maybe1, SigExp_constraint_maybeleft, _)) :: _ :: ( _
, ( MlyValue.Spec Spec1, _, _)) :: _ :: ( _, ( MlyValue.Ident Ident1, 
Ident1left, _)) :: rest671)) => let val  result = MlyValue.FunBind (fn
 _ => let val  (Ident as Ident1) = Ident1 ()
 val  (Spec as Spec1) = Spec1 ()
 val  (SigExp_constraint_maybe as SigExp_constraint_maybe1) = 
SigExp_constraint_maybe1 ()
 val  (StrExp as StrExp1) = StrExp1 ()
 val  (AndFunBind_opt as AndFunBind_opt1) = AndFunBind_opt1 ()
 in (
 let val strid_nu = inventStrId ()
			      val i_body = PP SigExp_constraint_maybeleft StrExpright
			      val i_spec = info_on_spec Spec
                          in FUNBIND
			       (PP Ident1left
				  (rightmost info_on_strexp StrExp
				             info_on_funbind AndFunBind_opt),
				mk_FunId Ident, strid_nu,
				SIGsigexp (i_spec, Spec),
				LETstrexp
				  (i_body,
				   DECstrdec
				     (i_spec,
				      OPENdec (i_spec,
					       [WITH_INFO (i_spec, longStrIdOfStrId strid_nu)])),
				   SigExp_constraint_maybe SigExp_constraint_maybeleft StrExp),
				AndFunBind_opt)
                          end 
)
end)
 in ( LrTable.NT 7, ( result, Ident1left, AndFunBind_opt1right), 
rest671)
end
|  ( 44, ( ( _, ( MlyValue.SigExp_constraint SigExp_constraint1, 
SigExp_constraint1left, SigExp_constraint1right)) :: rest671)) => let
 val  result = MlyValue.SigExp_constraint_maybe (fn _ => let val  (
SigExp_constraint as SigExp_constraint1) = SigExp_constraint1 ()
 in ( SigExp_constraint )
end)
 in ( LrTable.NT 25, ( result, SigExp_constraint1left, 
SigExp_constraint1right), rest671)
end
|  ( 45, ( rest671)) => let val  result = 
MlyValue.SigExp_constraint_maybe (fn _ => (
 (fn _ => fn strexp => strexp) ))
 in ( LrTable.NT 25, ( result, defaultPos, defaultPos), rest671)
end
|  ( 46, ( ( _, ( MlyValue.SigExp SigExp1, _, (SigExpright as 
SigExp1right))) :: ( _, ( _, COLON1left, _)) :: rest671)) => let val  
result = MlyValue.SigExp_constraint (fn _ => let val  (SigExp as 
SigExp1) = SigExp1 ()
 in (
 (fn leftpos => fn strexp =>
			   TRANSPARENT_CONSTRAINTstrexp
			     (PP leftpos SigExpright, strexp, SigExp)) 
)
end)
 in ( LrTable.NT 24, ( result, COLON1left, SigExp1right), rest671)
end
|  ( 47, ( ( _, ( MlyValue.SigExp SigExp1, _, (SigExpright as 
SigExp1right))) :: ( _, ( _, COLONGREATER1left, _)) :: rest671)) =>
 let val  result = MlyValue.SigExp_constraint (fn _ => let val  (
SigExp as SigExp1) = SigExp1 ()
 in (
 (fn leftpos => fn strexp =>
			   OPAQUE_CONSTRAINTstrexp
			     (PP leftpos SigExpright, strexp, SigExp)) 
)
end)
 in ( LrTable.NT 24, ( result, COLONGREATER1left, SigExp1right), 
rest671)
end
|  ( 48, ( ( _, ( MlyValue.FunBind FunBind1, _, FunBind1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndFunBind_opt (fn _ => let val  (FunBind as FunBind1) = 
FunBind1 ()
 in ( SOME FunBind )
end)
 in ( LrTable.NT 26, ( result, AND1left, FunBind1right), rest671)
end
|  ( 49, ( rest671)) => let val  result = MlyValue.AndFunBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 26, ( result, defaultPos, defaultPos), rest671)
end
|  ( 50, ( ( _, ( MlyValue.FunBind FunBind1, _, FunBind1right)) :: ( _
, ( _, (FUNCTORleft as FUNCTOR1left), _)) :: rest671)) => let val  
result = MlyValue.FunDec (fn _ => let val  (FunBind as FunBind1) = 
FunBind1 ()
 in (
 FUNCTORfundec (PP FUNCTORleft (right (info_on_funbind FunBind)),
					 FunBind) 
)
end)
 in ( LrTable.NT 5, ( result, FUNCTOR1left, FunBind1right), rest671)

end
|  ( 51, ( ( _, ( MlyValue.AndStrDesc_opt AndStrDesc_opt1, _, 
AndStrDesc_opt1right)) :: ( _, ( MlyValue.SigExp SigExp1, _, _)) :: _
 :: ( _, ( MlyValue.Ident Ident1, (Identleft as Ident1left), _)) :: 
rest671)) => let val  result = MlyValue.StrDesc (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 val  (SigExp as SigExp1) = SigExp1 ()
 val  (AndStrDesc_opt as AndStrDesc_opt1) = AndStrDesc_opt1 ()
 in (
 STRDESC (PP Identleft
				     (rightmost info_on_sigexp SigExp
				                info_on_strdesc AndStrDesc_opt),
				   mk_StrId Ident, SigExp, AndStrDesc_opt) 
)
end)
 in ( LrTable.NT 8, ( result, Ident1left, AndStrDesc_opt1right), 
rest671)
end
|  ( 52, ( ( _, ( MlyValue.StrDesc StrDesc1, _, StrDesc1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndStrDesc_opt (fn _ => let val  (StrDesc as StrDesc1) = 
StrDesc1 ()
 in ( SOME StrDesc )
end)
 in ( LrTable.NT 29, ( result, AND1left, StrDesc1right), rest671)
end
|  ( 53, ( rest671)) => let val  result = MlyValue.AndStrDesc_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 29, ( result, defaultPos, defaultPos), rest671)
end
|  ( 54, ( ( _, ( MlyValue.AndExDesc_opt AndExDesc_opt1, _, 
AndExDesc_opt1right)) :: ( _, ( MlyValue.OfTy_opt OfTy_opt1, _, _)) ::
 ( _, ( MlyValue.Ident Ident1, (Identleft as Ident1left), Identright))
 :: rest671)) => let val  result = MlyValue.ExDesc (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 val  (OfTy_opt as OfTy_opt1) = OfTy_opt1 ()
 val  (AndExDesc_opt as AndExDesc_opt1) = AndExDesc_opt1 ()
 in (
 EXDESC (PP Identleft
				    (rightmost_of_three  Identright
				                get_info_ty OfTy_opt
						info_on_exdesc AndExDesc_opt),
				  mk_Id Ident, OfTy_opt, AndExDesc_opt) 
)
end)
 in ( LrTable.NT 9, ( result, Ident1left, AndExDesc_opt1right), 
rest671)
end
|  ( 55, ( ( _, ( MlyValue.ExDesc ExDesc1, _, ExDesc1right)) :: ( _, (
 _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndExDesc_opt (fn _ => let val  (ExDesc as ExDesc1) = ExDesc1
 ()
 in ( SOME ExDesc )
end)
 in ( LrTable.NT 30, ( result, AND1left, ExDesc1right), rest671)
end
|  ( 56, ( rest671)) => let val  result = MlyValue.AndExDesc_opt (fn _
 => ( NONE ))
 in ( LrTable.NT 30, ( result, defaultPos, defaultPos), rest671)
end
|  ( 57, ( ( _, ( MlyValue.BarConDesc_opt BarConDesc_opt1, _, 
BarConDesc_opt1right)) :: ( _, ( MlyValue.OfTy_opt OfTy_opt1, _, _))
 :: ( _, ( MlyValue.OpIdent OpIdent1, (OpIdentleft as OpIdent1left), 
OpIdentright)) :: rest671)) => let val  result = MlyValue.ConDesc (fn
 _ => let val  (OpIdent as OpIdent1) = OpIdent1 ()
 val  (OfTy_opt as OfTy_opt1) = OfTy_opt1 ()
 val  (BarConDesc_opt as BarConDesc_opt1) = BarConDesc_opt1 ()
 in (
 let val OP_OPT (id, _) = OpIdent
                          in CONDESC
			       (PP OpIdentleft
				  (rightmost_of_three OpIdentright
				              get_info_ty OfTy_opt
					      info_on_condesc BarConDesc_opt),
				mk_Id id, OfTy_opt, BarConDesc_opt)
                          end 
)
end)
 in ( LrTable.NT 10, ( result, OpIdent1left, BarConDesc_opt1right), 
rest671)
end
|  ( 58, ( ( _, ( MlyValue.ConDesc ConDesc1, _, ConDesc1right)) :: ( _
, ( _, BAR1left, _)) :: rest671)) => let val  result = 
MlyValue.BarConDesc_opt (fn _ => let val  (ConDesc as ConDesc1) = 
ConDesc1 ()
 in ( SOME ConDesc )
end)
 in ( LrTable.NT 31, ( result, BAR1left, ConDesc1right), rest671)
end
|  ( 59, ( rest671)) => let val  result = MlyValue.BarConDesc_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 31, ( result, defaultPos, defaultPos), rest671)
end
|  ( 60, ( ( _, ( MlyValue.AndDatDesc_opt AndDatDesc_opt1, _, 
AndDatDesc_opt1right)) :: ( _, ( MlyValue.ConDesc ConDesc1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( 
MlyValue.TyVarSeq TyVarSeq1, (TyVarSeqleft as TyVarSeq1left), _)) :: 
rest671)) => let val  result = MlyValue.DatDesc (fn _ => let val  (
TyVarSeq as TyVarSeq1) = TyVarSeq1 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (ConDesc as ConDesc1) = ConDesc1 ()
 val  (AndDatDesc_opt as AndDatDesc_opt1) = AndDatDesc_opt1 ()
 in (
 DATDESC (PP TyVarSeqleft
				     (rightmost info_on_condesc ConDesc
				                info_on_datdesc AndDatDesc_opt),
				   TyVarSeq, mk_TyCon TypeIdent,
				   ConDesc, AndDatDesc_opt) 
)
end)
 in ( LrTable.NT 11, ( result, TyVarSeq1left, AndDatDesc_opt1right), 
rest671)
end
|  ( 61, ( ( _, ( MlyValue.AndDatDesc_opt AndDatDesc_opt1, _, 
AndDatDesc_opt1right)) :: ( _, ( MlyValue.ConDesc ConDesc1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, (TypeIdentleft as 
TypeIdent1left), _)) :: rest671)) => let val  result = 
MlyValue.DatDesc_zero_arity (fn _ => let val  (TypeIdent as TypeIdent1
) = TypeIdent1 ()
 val  (ConDesc as ConDesc1) = ConDesc1 ()
 val  (AndDatDesc_opt as AndDatDesc_opt1) = AndDatDesc_opt1 ()
 in (
 DATDESC (PP TypeIdentleft
				     (rightmost info_on_condesc ConDesc
				                info_on_datdesc AndDatDesc_opt),
				   [], mk_TyCon TypeIdent,
				   ConDesc, AndDatDesc_opt) 
)
end)
 in ( LrTable.NT 12, ( result, TypeIdent1left, AndDatDesc_opt1right), 
rest671)
end
|  ( 62, ( ( _, ( MlyValue.AndDatDesc_opt AndDatDesc_opt1, _, 
AndDatDesc_opt1right)) :: ( _, ( MlyValue.ConDesc ConDesc1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( 
MlyValue.TyVarSeq1 TyVarSeq11, (TyVarSeq1left as TyVarSeq11left), _))
 :: rest671)) => let val  result = MlyValue.DatDesc_nonzero_arity (fn
 _ => let val  (TyVarSeq1 as TyVarSeq11) = TyVarSeq11 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (ConDesc as ConDesc1) = ConDesc1 ()
 val  (AndDatDesc_opt as AndDatDesc_opt1) = AndDatDesc_opt1 ()
 in (
 DATDESC (PP TyVarSeq1left
				     (rightmost info_on_condesc ConDesc
				                info_on_datdesc AndDatDesc_opt),
				   TyVarSeq1, mk_TyCon TypeIdent,
				   ConDesc, AndDatDesc_opt) 
)
end)
 in ( LrTable.NT 13, ( result, TyVarSeq11left, AndDatDesc_opt1right), 
rest671)
end
|  ( 63, ( ( _, ( MlyValue.DatDesc DatDesc1, _, DatDesc1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndDatDesc_opt (fn _ => let val  (DatDesc as DatDesc1) = 
DatDesc1 ()
 in ( SOME DatDesc )
end)
 in ( LrTable.NT 32, ( result, AND1left, DatDesc1right), rest671)
end
|  ( 64, ( rest671)) => let val  result = MlyValue.AndDatDesc_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 32, ( result, defaultPos, defaultPos), rest671)
end
|  ( 65, ( ( _, ( MlyValue.AndTypDesc_opt AndTypDesc_opt1, _, 
AndTypDesc_opt1right)) :: ( _, ( MlyValue.TypeIdent TypeIdent1, _, 
TypeIdentright)) :: ( _, ( MlyValue.TyVarSeq TyVarSeq1, (TyVarSeqleft
 as TyVarSeq1left), _)) :: rest671)) => let val  result = 
MlyValue.TypDesc (fn _ => let val  (TyVarSeq as TyVarSeq1) = TyVarSeq1
 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (AndTypDesc_opt as AndTypDesc_opt1) = AndTypDesc_opt1 ()
 in (
 TYPDESC (PP TyVarSeqleft
				     (rightmost' TypeIdentright info_on_typdesc AndTypDesc_opt),
				   TyVarSeq, mk_TyCon TypeIdent, AndTypDesc_opt) 
)
end)
 in ( LrTable.NT 14, ( result, TyVarSeq1left, AndTypDesc_opt1right), 
rest671)
end
|  ( 66, ( ( _, ( MlyValue.TypDesc TypDesc1, _, TypDesc1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndTypDesc_opt (fn _ => let val  (TypDesc as TypDesc1) = 
TypDesc1 ()
 in ( SOME TypDesc )
end)
 in ( LrTable.NT 33, ( result, AND1left, TypDesc1right), rest671)
end
|  ( 67, ( rest671)) => let val  result = MlyValue.AndTypDesc_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 33, ( result, defaultPos, defaultPos), rest671)
end
|  ( 68, ( ( _, ( MlyValue.TypAbbreviationAND_seq1 
TypAbbreviationAND_seq11, _, TypAbbreviationAND_seq11right)) :: _ :: (
 _, ( MlyValue.TypAbbreviation TypAbbreviation1, TypAbbreviation1left,
 _)) :: rest671)) => let val  result = 
MlyValue.TypAbbreviationAND_seq1 (fn _ => let val  (TypAbbreviation
 as TypAbbreviation1) = TypAbbreviation1 ()
 val  (TypAbbreviationAND_seq1 as TypAbbreviationAND_seq11) = 
TypAbbreviationAND_seq11 ()
 in ( TypAbbreviation :: TypAbbreviationAND_seq1 )
end)
 in ( LrTable.NT 34, ( result, TypAbbreviation1left, 
TypAbbreviationAND_seq11right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.TypAbbreviation TypAbbreviation1, 
TypAbbreviation1left, TypAbbreviation1right)) :: rest671)) => let val 
 result = MlyValue.TypAbbreviationAND_seq1 (fn _ => let val  (
TypAbbreviation as TypAbbreviation1) = TypAbbreviation1 ()
 in ( [TypAbbreviation] )
end)
 in ( LrTable.NT 34, ( result, TypAbbreviation1left, 
TypAbbreviation1right), rest671)
end
|  ( 70, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: _ :: 
( _, ( MlyValue.TypeIdent TypeIdent1, _, TypeIdentright)) :: ( _, ( 
MlyValue.TyVarSeq TyVarSeq1, (TyVarSeqleft as TyVarSeq1left), _)) :: 
rest671)) => let val  result = MlyValue.TypAbbreviation (fn _ => let
 val  (TyVarSeq as TyVarSeq1) = TyVarSeq1 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (Ty as Ty1) = Ty1 ()
 in (
 (TyVarSeq, mk_TyCon TypeIdent, Ty,
			   PP TyVarSeqleft Tyright, PP TyVarSeqleft TypeIdentright) 
)
end)
 in ( LrTable.NT 15, ( result, TyVarSeq1left, Ty1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.AndValDesc_opt AndValDesc_opt1, _, 
AndValDesc_opt1right)) :: ( _, ( MlyValue.Ty Ty1, _, Tyright)) :: _ ::
 ( _, ( MlyValue.EqIdent EqIdent1, (EqIdentleft as EqIdent1left), _))
 :: rest671)) => let val  result = MlyValue.ValDesc (fn _ => let val 
 (EqIdent as EqIdent1) = EqIdent1 ()
 val  (Ty as Ty1) = Ty1 ()
 val  (AndValDesc_opt as AndValDesc_opt1) = AndValDesc_opt1 ()
 in (
 VALDESC (PP EqIdentleft
				     (rightmost' Tyright info_on_valdesc AndValDesc_opt),
				   mk_Id EqIdent, Ty, AndValDesc_opt) 
)
end)
 in ( LrTable.NT 16, ( result, EqIdent1left, AndValDesc_opt1right), 
rest671)
end
|  ( 72, ( ( _, ( MlyValue.ValDesc ValDesc1, _, ValDesc1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndValDesc_opt (fn _ => let val  (ValDesc as ValDesc1) = 
ValDesc1 ()
 in ( SOME ValDesc )
end)
 in ( LrTable.NT 35, ( result, AND1left, ValDesc1right), rest671)
end
|  ( 73, ( rest671)) => let val  result = MlyValue.AndValDesc_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 35, ( result, defaultPos, defaultPos), rest671)
end
|  ( 74, ( ( _, ( MlyValue.ValDesc ValDesc1, _, ValDesc1right)) :: ( _
, ( _, (VALleft as VAL1left), _)) :: rest671)) => let val  result = 
MlyValue.OneSpec (fn _ => let val  (ValDesc as ValDesc1) = ValDesc1 ()
 in (
 VALspec (PP VALleft (right (info_on_valdesc ValDesc)),
				   ValDesc) 
)
end)
 in ( LrTable.NT 18, ( result, VAL1left, ValDesc1right), rest671)
end
|  ( 75, ( ( _, ( MlyValue.TypDesc TypDesc1, _, TypDesc1right)) :: ( _
, ( _, (TYPEleft as TYPE1left), _)) :: rest671)) => let val  result = 
MlyValue.OneSpec (fn _ => let val  (TypDesc as TypDesc1) = TypDesc1 ()
 in (
 TYPEspec (PP TYPEleft (right (info_on_typdesc TypDesc)),
				    TypDesc) 
)
end)
 in ( LrTable.NT 18, ( result, TYPE1left, TypDesc1right), rest671)
end
|  ( 76, ( ( _, ( MlyValue.TypDesc TypDesc1, _, TypDesc1right)) :: ( _
, ( _, (EQTYPEleft as EQTYPE1left), _)) :: rest671)) => let val  
result = MlyValue.OneSpec (fn _ => let val  (TypDesc as TypDesc1) = 
TypDesc1 ()
 in (
 EQTYPEspec (PP EQTYPEleft (right (info_on_typdesc TypDesc)),
				      TypDesc) 
)
end)
 in ( LrTable.NT 18, ( result, EQTYPE1left, TypDesc1right), rest671)

end
|  ( 77, ( ( _, ( MlyValue.DatDesc_zero_arity DatDesc_zero_arity1, _, 
DatDesc_zero_arity1right)) :: ( _, ( _, (DATATYPEleft as DATATYPE1left
), _)) :: rest671)) => let val  result = MlyValue.OneSpec (fn _ => let
 val  (DatDesc_zero_arity as DatDesc_zero_arity1) = 
DatDesc_zero_arity1 ()
 in (
 DATATYPEspec (PP DATATYPEleft
					  (right (info_on_datdesc DatDesc_zero_arity)),
				        DatDesc_zero_arity) 
)
end)
 in ( LrTable.NT 18, ( result, DATATYPE1left, DatDesc_zero_arity1right
), rest671)
end
|  ( 78, ( ( _, ( MlyValue.DatDesc_nonzero_arity 
DatDesc_nonzero_arity1, _, DatDesc_nonzero_arity1right)) :: ( _, ( _,
 (DATATYPEleft as DATATYPE1left), _)) :: rest671)) => let val  result
 = MlyValue.OneSpec (fn _ => let val  (DatDesc_nonzero_arity as 
DatDesc_nonzero_arity1) = DatDesc_nonzero_arity1 ()
 in (
 DATATYPEspec (PP DATATYPEleft
					  (right (info_on_datdesc DatDesc_nonzero_arity)),
					DatDesc_nonzero_arity) 
)
end)
 in ( LrTable.NT 18, ( result, DATATYPE1left, 
DatDesc_nonzero_arity1right), rest671)
end
|  ( 79, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, _, (
LongTypeIdentright as LongTypeIdent1right))) :: _ :: _ :: ( _, ( 
MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( _, DATATYPE1left, _))
 :: rest671)) => let val  result = MlyValue.OneSpec (fn _ => let val 
 (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 in (
 DATATYPE_REPLICATIONspec
			    (PP DATATYPE1left LongTypeIdentright,
			     mk_TyCon TypeIdent, mk_LongTyCon LongTypeIdent) 
)
end)
 in ( LrTable.NT 18, ( result, DATATYPE1left, LongTypeIdent1right), 
rest671)
end
|  ( 80, ( ( _, ( MlyValue.ExDesc ExDesc1, _, ExDesc1right)) :: ( _, (
 _, (EXCEPTIONleft as EXCEPTION1left), _)) :: rest671)) => let val  
result = MlyValue.OneSpec (fn _ => let val  (ExDesc as ExDesc1) = 
ExDesc1 ()
 in (
 EXCEPTIONspec (PP EXCEPTIONleft (right (info_on_exdesc ExDesc)),
					 ExDesc) 
)
end)
 in ( LrTable.NT 18, ( result, EXCEPTION1left, ExDesc1right), rest671)

end
|  ( 81, ( ( _, ( MlyValue.StrDesc StrDesc1, _, StrDesc1right)) :: ( _
, ( _, (STRUCTUREleft as STRUCTURE1left), _)) :: rest671)) => let val 
 result = MlyValue.OneSpec (fn _ => let val  (StrDesc as StrDesc1) = 
StrDesc1 ()
 in (
 STRUCTUREspec (PP STRUCTUREleft (right (info_on_strdesc StrDesc)),
					 StrDesc) 
)
end)
 in ( LrTable.NT 18, ( result, STRUCTURE1left, StrDesc1right), rest671
)
end
|  ( 82, ( ( _, ( MlyValue.SigExp SigExp1, _, (SigExpright as 
SigExp1right))) :: ( _, ( _, (INCLUDEleft as INCLUDE1left), _)) :: 
rest671)) => let val  result = MlyValue.OneSpec (fn _ => let val  (
SigExp as SigExp1) = SigExp1 ()
 in ( INCLUDEspec (PP INCLUDEleft SigExpright, SigExp) )
end)
 in ( LrTable.NT 18, ( result, INCLUDE1left, SigExp1right), rest671)

end
|  ( 83, ( ( _, ( MlyValue.TypAbbreviationAND_seq1 
TypAbbreviationAND_seq11, _, TypAbbreviationAND_seq11right)) :: ( _, (
 _, TYPE1left, _)) :: rest671)) => let val  result = MlyValue.OneSpec
 (fn _ => let val  (TypAbbreviationAND_seq1 as 
TypAbbreviationAND_seq11) = TypAbbreviationAND_seq11 ()
 in (
 fold_specs_to_spec
			    (map rewrite_type_abbreviation_spec TypAbbreviationAND_seq1) 
)
end)
 in ( LrTable.NT 18, ( result, TYPE1left, 
TypAbbreviationAND_seq11right), rest671)
end
|  ( 84, ( ( _, ( MlyValue.Ident_seq2 Ident_seq21, _, Ident_seq21right
)) :: ( _, ( _, INCLUDE1left, _)) :: rest671)) => let val  result = 
MlyValue.OneSpec (fn _ => let val  (Ident_seq2 as Ident_seq21) = 
Ident_seq21 ()
 in (
 fold_specs_to_spec
			    (map (fn WITH_INFO (i, Ident) =>
				      (i, INCLUDEspec (i, SIGIDsigexp (i, mk_SigId Ident))))
			       Ident_seq2) 
)
end)
 in ( LrTable.NT 18, ( result, INCLUDE1left, Ident_seq21right), 
rest671)
end
|  ( 85, ( ( _, ( MlyValue.OneSpec OneSpec1, _, OneSpec1right)) :: ( _
, ( MlyValue.Spec Spec1, (Specleft as Spec1left), _)) :: rest671)) =>
 let val  result = MlyValue.Spec (fn _ => let val  (Spec as Spec1) = 
Spec1 ()
 val  (OneSpec as OneSpec1) = OneSpec1 ()
 in (
 composeSpec (PP Specleft (right (info_on_spec OneSpec)),
				       Spec, OneSpec) 
)
end)
 in ( LrTable.NT 17, ( result, Spec1left, OneSpec1right), rest671)
end
|  ( 86, ( ( _, ( MlyValue.LongTypeIdentEq_seq2 LongTypeIdentEq_seq21,
 _, (LongTypeIdentEq_seq2right as LongTypeIdentEq_seq21right))) :: _
 :: _ :: ( _, ( MlyValue.Spec Spec1, (Specleft as Spec1left), _)) :: 
rest671)) => let val  result = MlyValue.Spec (fn _ => let val  (Spec
 as Spec1) = Spec1 ()
 val  (LongTypeIdentEq_seq2 as LongTypeIdentEq_seq21) = 
LongTypeIdentEq_seq21 ()
 in (
 SHARING_TYPEspec (PP Specleft LongTypeIdentEq_seq2right,
					    Spec,
					    wi_Convert mk_LongTyCon LongTypeIdentEq_seq2) 
)
end)
 in ( LrTable.NT 17, ( result, Spec1left, LongTypeIdentEq_seq21right),
 rest671)
end
|  ( 87, ( ( _, ( MlyValue.LongIdentEq_seq2 LongIdentEq_seq21, _, (
LongIdentEq_seq2right as LongIdentEq_seq21right))) :: _ :: ( _, ( 
MlyValue.Spec Spec1, (Specleft as Spec1left), _)) :: rest671)) => let
 val  result = MlyValue.Spec (fn _ => let val  (Spec as Spec1) = Spec1
 ()
 val  (LongIdentEq_seq2 as LongIdentEq_seq21) = LongIdentEq_seq21 ()
 in (
 SHARINGspec (PP Specleft LongIdentEq_seq2right,
				       Spec, wi_Convert mk_LongStrId LongIdentEq_seq2) 
)
end)
 in ( LrTable.NT 17, ( result, Spec1left, LongIdentEq_seq21right), 
rest671)
end
|  ( 88, ( ( _, ( _, _, SEMICOLON1right)) :: ( _, ( MlyValue.Spec 
Spec1, Spec1left, _)) :: rest671)) => let val  result = MlyValue.Spec
 (fn _ => let val  (Spec as Spec1) = Spec1 ()
 in ( Spec )
end)
 in ( LrTable.NT 17, ( result, Spec1left, SEMICOLON1right), rest671)

end
|  ( 89, ( rest671)) => let val  result = MlyValue.Spec (fn _ => (
 EMPTYspec (PP defaultPos defaultPos) ))
 in ( LrTable.NT 17, ( result, defaultPos, defaultPos), rest671)
end
|  ( 90, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.StrDec StrDec1, _, _)) :: ( _, ( _, (STRUCTleft as 
STRUCT1left), _)) :: rest671)) => let val  result = MlyValue.StrExp
 (fn _ => let val  (StrDec as StrDec1) = StrDec1 ()
 in ( STRUCTstrexp (PP STRUCTleft ENDright, StrDec) )
end)
 in ( LrTable.NT 23, ( result, STRUCT1left, END1right), rest671)
end
|  ( 91, ( ( _, ( MlyValue.LongIdent LongIdent1, (LongIdentleft as 
LongIdent1left), (LongIdentright as LongIdent1right))) :: rest671)) =>
 let val  result = MlyValue.StrExp (fn _ => let val  (LongIdent as 
LongIdent1) = LongIdent1 ()
 in (
 LONGSTRIDstrexp (PP LongIdentleft LongIdentright,
					   mk_LongStrId LongIdent) 
)
end)
 in ( LrTable.NT 23, ( result, LongIdent1left, LongIdent1right), 
rest671)
end
|  ( 92, ( ( _, ( MlyValue.SigExp_constraint SigExp_constraint1, _, 
SigExp_constraint1right)) :: ( _, ( MlyValue.StrExp StrExp1, (
StrExpleft as StrExp1left), _)) :: rest671)) => let val  result = 
MlyValue.StrExp (fn _ => let val  (StrExp as StrExp1) = StrExp1 ()
 val  (SigExp_constraint as SigExp_constraint1) = SigExp_constraint1
 ()
 in ( SigExp_constraint StrExpleft StrExp )
end)
 in ( LrTable.NT 23, ( result, StrExp1left, SigExp_constraint1right), 
rest671)
end
|  ( 93, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.StrExp StrExp1, _, _)) :: _ :: ( _, ( MlyValue.Ident Ident1,
 (Identleft as Ident1left), _)) :: rest671)) => let val  result = 
MlyValue.StrExp (fn _ => let val  (Ident as Ident1) = Ident1 ()
 val  (StrExp as StrExp1) = StrExp1 ()
 in (
 APPstrexp (PP Identleft RPARENright,
				     mk_FunId Ident, StrExp) 
)
end)
 in ( LrTable.NT 23, ( result, Ident1left, RPAREN1right), rest671)
end
|  ( 94, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.StrExp StrExp1, _, _)) :: _ :: ( _, ( MlyValue.StrDec StrDec1
, _, _)) :: ( _, ( _, (LETleft as LET1left), _)) :: rest671)) => let
 val  result = MlyValue.StrExp (fn _ => let val  (StrDec as StrDec1) =
 StrDec1 ()
 val  (StrExp as StrExp1) = StrExp1 ()
 in ( LETstrexp (PP LETleft ENDright, StrDec, StrExp) )
end)
 in ( LrTable.NT 23, ( result, LET1left, END1right), rest671)
end
|  ( 95, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.StrDec StrDec1, StrDecleft, _)) :: _ :: ( _, ( MlyValue.Ident
 Ident1, (Identleft as Ident1left), _)) :: rest671)) => let val  
result = MlyValue.StrExp (fn _ => let val  (Ident as Ident1) = Ident1
 ()
 val  (StrDec as StrDec1) = StrDec1 ()
 in (
 APPstrexp (PP Identleft RPARENright, mk_FunId Ident,
				     STRUCTstrexp
				       (PP StrDecleft (right (info_on_strdec StrDec)),
					StrDec)) 
)
end)
 in ( LrTable.NT 23, ( result, Ident1left, RPAREN1right), rest671)
end
|  ( 96, ( ( _, ( MlyValue.OneStrDec_or_SEMICOLON 
OneStrDec_or_SEMICOLON1, _, OneStrDec_or_SEMICOLON1right)) :: ( _, ( 
MlyValue.NonEmptyStrDec NonEmptyStrDec1, (NonEmptyStrDecleft as 
NonEmptyStrDec1left), _)) :: rest671)) => let val  result = 
MlyValue.NonEmptyStrDec (fn _ => let val  (NonEmptyStrDec as 
NonEmptyStrDec1) = NonEmptyStrDec1 ()
 val  (OneStrDec_or_SEMICOLON as OneStrDec_or_SEMICOLON1) = 
OneStrDec_or_SEMICOLON1 ()
 in (
 (case OneStrDec_or_SEMICOLON of
			     SOME strdec =>
			       composeStrDec (PP NonEmptyStrDecleft
					        (right (info_on_strdec strdec)),
					      NonEmptyStrDec, strdec)
			   | NONE =>
			       NonEmptyStrDec) 
)
end)
 in ( LrTable.NT 42, ( result, NonEmptyStrDec1left, 
OneStrDec_or_SEMICOLON1right), rest671)
end
|  ( 97, ( ( _, ( MlyValue.OneStrDec_or_SEMICOLON 
OneStrDec_or_SEMICOLON1, OneStrDec_or_SEMICOLON1left, 
OneStrDec_or_SEMICOLON1right)) :: rest671)) => let val  result = 
MlyValue.NonEmptyStrDec (fn _ => let val  (OneStrDec_or_SEMICOLON as 
OneStrDec_or_SEMICOLON1) = OneStrDec_or_SEMICOLON1 ()
 in (
 (case OneStrDec_or_SEMICOLON of
			     SOME strdec => strdec
			   | NONE => EMPTYstrdec (PP defaultPos defaultPos)) 
)
end)
 in ( LrTable.NT 42, ( result, OneStrDec_or_SEMICOLON1left, 
OneStrDec_or_SEMICOLON1right), rest671)
end
|  ( 98, ( ( _, ( MlyValue.NonEmptyStrDec NonEmptyStrDec1, 
NonEmptyStrDec1left, NonEmptyStrDec1right)) :: rest671)) => let val  
result = MlyValue.StrDec (fn _ => let val  (NonEmptyStrDec as 
NonEmptyStrDec1) = NonEmptyStrDec1 ()
 in ( NonEmptyStrDec )
end)
 in ( LrTable.NT 22, ( result, NonEmptyStrDec1left, 
NonEmptyStrDec1right), rest671)
end
|  ( 99, ( rest671)) => let val  result = MlyValue.StrDec (fn _ => (
 EMPTYstrdec (PP defaultPos defaultPos) ))
 in ( LrTable.NT 22, ( result, defaultPos, defaultPos), rest671)
end
|  ( 100, ( ( _, ( MlyValue.OneStrDec OneStrDec1, OneStrDec1left, 
OneStrDec1right)) :: rest671)) => let val  result = 
MlyValue.OneStrDec_or_SEMICOLON (fn _ => let val  (OneStrDec as 
OneStrDec1) = OneStrDec1 ()
 in ( SOME OneStrDec )
end)
 in ( LrTable.NT 41, ( result, OneStrDec1left, OneStrDec1right), 
rest671)
end
|  ( 101, ( ( _, ( _, SEMICOLON1left, SEMICOLON1right)) :: rest671))
 => let val  result = MlyValue.OneStrDec_or_SEMICOLON (fn _ => ( NONE 
))
 in ( LrTable.NT 41, ( result, SEMICOLON1left, SEMICOLON1right), 
rest671)
end
|  ( 102, ( ( _, ( MlyValue.OneDec_sans_LOCAL OneDec_sans_LOCAL1, (
OneDec_sans_LOCALleft as OneDec_sans_LOCAL1left), 
OneDec_sans_LOCAL1right)) :: rest671)) => let val  result = 
MlyValue.OneStrDec (fn _ => let val  (OneDec_sans_LOCAL as 
OneDec_sans_LOCAL1) = OneDec_sans_LOCAL1 ()
 in (
 DECstrdec (PP OneDec_sans_LOCALleft
                                        (right (get_info_dec OneDec_sans_LOCAL)),
                                     OneDec_sans_LOCAL) 
)
end)
 in ( LrTable.NT 6, ( result, OneDec_sans_LOCAL1left, 
OneDec_sans_LOCAL1right), rest671)
end
|  ( 103, ( ( _, ( MlyValue.StrBind StrBind1, _, StrBind1right)) :: (
 _, ( _, (STRUCTUREleft as STRUCTURE1left), _)) :: rest671)) => let
 val  result = MlyValue.OneStrDec (fn _ => let val  (StrBind as 
StrBind1) = StrBind1 ()
 in (
 STRUCTUREstrdec (PP STRUCTUREleft
					     (right (info_on_strbind StrBind)),
					   StrBind) 
)
end)
 in ( LrTable.NT 6, ( result, STRUCTURE1left, StrBind1right), rest671)

end
|  ( 104, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.StrDec StrDec2, _, _)) :: _ :: ( _, ( MlyValue.StrDec StrDec1
, _, _)) :: ( _, ( _, (LOCALleft as LOCAL1left), _)) :: rest671)) =>
 let val  result = MlyValue.OneStrDec (fn _ => let val  StrDec1 = 
StrDec1 ()
 val  StrDec2 = StrDec2 ()
 in ( LOCALstrdec (PP LOCALleft ENDright, StrDec1, StrDec2) )
end)
 in ( LrTable.NT 6, ( result, LOCAL1left, END1right), rest671)
end
|  ( 105, ( ( _, ( MlyValue.AndStrBind_opt AndStrBind_opt1, _, 
AndStrBind_opt1right)) :: ( _, ( MlyValue.StrExp StrExp1, _, _)) :: _
 :: ( _, ( MlyValue.SigExp_constraint_maybe SigExp_constraint_maybe1, 
SigExp_constraint_maybeleft, _)) :: ( _, ( MlyValue.Ident Ident1, (
Identleft as Ident1left), _)) :: rest671)) => let val  result = 
MlyValue.StrBind (fn _ => let val  (Ident as Ident1) = Ident1 ()
 val  (SigExp_constraint_maybe as SigExp_constraint_maybe1) = 
SigExp_constraint_maybe1 ()
 val  (StrExp as StrExp1) = StrExp1 ()
 val  (AndStrBind_opt as AndStrBind_opt1) = AndStrBind_opt1 ()
 in (
 STRBIND (PP Identleft
				     (rightmost info_on_strexp StrExp
				                info_on_strbind AndStrBind_opt),
				   mk_StrId Ident, SigExp_constraint_maybe SigExp_constraint_maybeleft StrExp,
				   AndStrBind_opt) 
)
end)
 in ( LrTable.NT 21, ( result, Ident1left, AndStrBind_opt1right), 
rest671)
end
|  ( 106, ( ( _, ( MlyValue.StrBind StrBind1, _, StrBind1right)) :: (
 _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndStrBind_opt (fn _ => let val  (StrBind as StrBind1) = 
StrBind1 ()
 in ( SOME StrBind )
end)
 in ( LrTable.NT 27, ( result, AND1left, StrBind1right), rest671)
end
|  ( 107, ( rest671)) => let val  result = MlyValue.AndStrBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 27, ( result, defaultPos, defaultPos), rest671)
end
|  ( 108, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.Spec Spec1, _, _)) :: ( _, ( _, (SIGleft as SIG1left), _)) ::
 rest671)) => let val  result = MlyValue.SigExp (fn _ => let val  (
Spec as Spec1) = Spec1 ()
 in ( SIGsigexp (PP SIGleft ENDright, Spec) )
end)
 in ( LrTable.NT 20, ( result, SIG1left, END1right), rest671)
end
|  ( 109, ( ( _, ( MlyValue.Ident Ident1, (Identleft as Ident1left), (
Identright as Ident1right))) :: rest671)) => let val  result = 
MlyValue.SigExp (fn _ => let val  (Ident as Ident1) = Ident1 ()
 in ( SIGIDsigexp (PP Identleft Identright, mk_SigId Ident) )
end)
 in ( LrTable.NT 20, ( result, Ident1left, Ident1right), rest671)
end
|  ( 110, ( ( _, ( MlyValue.WhereDesc WhereDesc1, _, WhereDesc1right))
 :: _ :: ( _, ( MlyValue.SigExp SigExp1, (SigExpleft as SigExp1left),
 _)) :: rest671)) => let val  result = MlyValue.SigExp (fn _ => let
 val  (SigExp as SigExp1) = SigExp1 ()
 val  (WhereDesc as WhereDesc1) = WhereDesc1 ()
 in ( WhereDesc(SigExpleft,SigExp) )
end)
 in ( LrTable.NT 20, ( result, SigExp1left, WhereDesc1right), rest671)

end
|  ( 111, ( ( _, ( MlyValue.AndWhereDesc_opt AndWhereDesc_opt1, _, 
AndWhereDesc_opt1right)) :: ( _, ( MlyValue.Ty Ty1, _, Tyright)) :: _
 :: ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, _, _)) :: ( _, ( 
MlyValue.TyVarSeq TyVarSeq1, _, _)) :: ( _, ( _, TYPE1left, _)) :: 
rest671)) => let val  result = MlyValue.WhereDesc (fn _ => let val  (
TyVarSeq as TyVarSeq1) = TyVarSeq1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 val  (Ty as Ty1) = Ty1 ()
 val  (AndWhereDesc_opt as AndWhereDesc_opt1) = AndWhereDesc_opt1 ()
 in (
 fn (sigexpleft,sigexp) =>
                             case AndWhereDesc_opt
                               of SOME f => f (sigexpleft, WHERE_TYPEsigexp (PP sigexpleft Tyright,
					                                     sigexp, TyVarSeq,
					                                     mk_LongTyCon LongTypeIdent, Ty))
                                | NONE => WHERE_TYPEsigexp (PP sigexpleft Tyright,
					                    sigexp, TyVarSeq,
					                    mk_LongTyCon LongTypeIdent, Ty) 
)
end)
 in ( LrTable.NT 43, ( result, TYPE1left, AndWhereDesc_opt1right), 
rest671)
end
|  ( 112, ( ( _, ( MlyValue.WhereDesc WhereDesc1, _, WhereDesc1right))
 :: ( _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndWhereDesc_opt (fn _ => let val  (WhereDesc as WhereDesc1)
 = WhereDesc1 ()
 in ( SOME WhereDesc )
end)
 in ( LrTable.NT 44, ( result, AND1left, WhereDesc1right), rest671)

end
|  ( 113, ( rest671)) => let val  result = MlyValue.AndWhereDesc_opt
 (fn _ => ( NONE ))
 in ( LrTable.NT 44, ( result, defaultPos, defaultPos), rest671)
end
|  ( 114, ( ( _, ( MlyValue.SigBind SigBind1, _, SigBind1right)) :: (
 _, ( _, (SIGNATUREleft as SIGNATURE1left), _)) :: rest671)) => let
 val  result = MlyValue.SigDec (fn _ => let val  (SigBind as SigBind1)
 = SigBind1 ()
 in (
 SIGNATUREsigdec
			    (PP SIGNATUREleft (right (info_on_sigbind SigBind)),
			     SigBind) 
)
end)
 in ( LrTable.NT 3, ( result, SIGNATURE1left, SigBind1right), rest671)

end
|  ( 115, ( ( _, ( MlyValue.AndSigBind_opt AndSigBind_opt1, _, 
AndSigBind_opt1right)) :: ( _, ( MlyValue.SigExp SigExp1, _, _)) :: _
 :: ( _, ( MlyValue.Ident Ident1, (Identleft as Ident1left), _)) :: 
rest671)) => let val  result = MlyValue.SigBind (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 val  (SigExp as SigExp1) = SigExp1 ()
 val  (AndSigBind_opt as AndSigBind_opt1) = AndSigBind_opt1 ()
 in (
 SIGBIND (PP Identleft
				     (rightmost info_on_sigexp SigExp
				                info_on_sigbind AndSigBind_opt),
                                   mk_SigId Ident, SigExp, AndSigBind_opt) 
)
end)
 in ( LrTable.NT 19, ( result, Ident1left, AndSigBind_opt1right), 
rest671)
end
|  ( 116, ( ( _, ( MlyValue.SigBind SigBind1, _, SigBind1right)) :: (
 _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndSigBind_opt (fn _ => let val  (SigBind as SigBind1) = 
SigBind1 ()
 in ( SOME SigBind )
end)
 in ( LrTable.NT 28, ( result, AND1left, SigBind1right), rest671)
end
|  ( 117, ( rest671)) => let val  result = MlyValue.AndSigBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 28, ( result, defaultPos, defaultPos), rest671)
end
|  ( 118, ( ( _, ( MlyValue.SCon SCon1, (SConleft as SCon1left), (
SConright as SCon1right))) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (SCon as SCon1) = SCon1 ()
 in ( SCONatexp (PP SConleft SConright, SCon, NONE) )
end)
 in ( LrTable.NT 69, ( result, SCon1left, SCon1right), rest671)
end
|  ( 119, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( 
MlyValue.SCon SCon1, (SConleft as SCon1left), SConright)) :: rest671))
 => let val  result = MlyValue.AtExp (fn _ => let val  (SCon as SCon1)
 = SCon1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 SCONatexp (PP SConleft SConright, SCon,
                                     SOME (PP BACKQUOTEleft EqIdentright,
                                           RegVar.mk_Named EqIdent)) 
)
end)
 in ( LrTable.NT 69, ( result, SCon1left, EqIdent1right), rest671)
end
|  ( 120, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, _, _)) :: _ :: ( _, ( _, 
BACKQUOTEleft, _)) :: ( _, ( MlyValue.LongOpIdent LongOpIdent1, (
LongOpIdentleft as LongOpIdent1left), LongOpIdentright)) :: rest671))
 => let val  result = MlyValue.AtExp (fn _ => let val  (LongOpIdent
 as LongOpIdent1) = LongOpIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 let val OP_OPT (id, withOp) = LongOpIdent
                          in
                            IDENTatexp (PP LongOpIdentleft LongOpIdentright,
					 OP_OPT (mk_LongId id, withOp),
                                         SOME (PP BACKQUOTEleft RBRACKETright,
                                               map RegVar.mk_Named EqIdent_seq1))
                          end 
)
end)
 in ( LrTable.NT 69, ( result, LongOpIdent1left, RBRACKET1right), 
rest671)
end
|  ( 121, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( 
MlyValue.LongOpIdent LongOpIdent1, (LongOpIdentleft as 
LongOpIdent1left), LongOpIdentright)) :: rest671)) => let val  result
 = MlyValue.AtExp (fn _ => let val  (LongOpIdent as LongOpIdent1) = 
LongOpIdent1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 let val OP_OPT (id, withOp) = LongOpIdent
                          in
                            IDENTatexp (PP LongOpIdentleft LongOpIdentright,
					 OP_OPT (mk_LongId id, withOp),
                                         SOME (PP BACKQUOTEleft EqIdentright,
                                               [RegVar.mk_Named EqIdent]))
                          end 
)
end)
 in ( LrTable.NT 69, ( result, LongOpIdent1left, EqIdent1right), 
rest671)
end
|  ( 122, ( ( _, ( MlyValue.LongOpEqIdent LongOpEqIdent1, (
LongOpEqIdentleft as LongOpEqIdent1left), (LongOpEqIdentright as 
LongOpEqIdent1right))) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (LongOpEqIdent as LongOpEqIdent1) = 
LongOpEqIdent1 ()
 in (
 let val OP_OPT (id, withOp) = LongOpEqIdent
                          in
			    IDENTatexp (PP LongOpEqIdentleft LongOpEqIdentright,
					OP_OPT (mk_LongId id, withOp), NONE)
                          end 
)
end)
 in ( LrTable.NT 69, ( result, LongOpEqIdent1left, LongOpEqIdent1right
), rest671)
end
|  ( 123, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.ExpRow_opt ExpRow_opt1, _, _)) :: ( _, ( _, (LBRACEleft as 
LBRACE1left), _)) :: rest671)) => let val  result = MlyValue.AtExp (fn
 _ => let val  (ExpRow_opt as ExpRow_opt1) = ExpRow_opt1 ()
 in (
 RECORDatexp (PP LBRACEleft RBRACEright, ExpRow_opt,
                                       NONE) 
)
end)
 in ( LrTable.NT 69, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 124, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( _, _, 
RBRACEright)) :: ( _, ( MlyValue.ExpRow_opt ExpRow_opt1, _, _)) :: ( _
, ( _, (LBRACEleft as LBRACE1left), _)) :: rest671)) => let val  
result = MlyValue.AtExp (fn _ => let val  (ExpRow_opt as ExpRow_opt1)
 = ExpRow_opt1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 RECORDatexp (PP LBRACEleft RBRACEright, ExpRow_opt,
                                       SOME (PP BACKQUOTEleft EqIdentright,
                                             RegVar.mk_Named EqIdent)) 
)
end)
 in ( LrTable.NT 69, ( result, LBRACE1left, EqIdent1right), rest671)

end
|  ( 125, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.Exp_ Exp_1, _, _)) :: _ :: ( _, ( MlyValue.Dec Dec1, _, _))
 :: ( _, ( _, (LETleft as LET1left), _)) :: rest671)) => let val  
result = MlyValue.AtExp (fn _ => let val  (Dec as Dec1) = Dec1 ()
 val  (Exp_ as Exp_1) = Exp_1 ()
 in ( LETatexp (PP LETleft ENDright, Dec, Exp_) )
end)
 in ( LrTable.NT 69, ( result, LET1left, END1right), rest671)
end
|  ( 126, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.Exp_ Exp_1, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left),
 _)) :: rest671)) => let val  result = MlyValue.AtExp (fn _ => let
 val  (Exp_ as Exp_1) = Exp_1 ()
 in ( PARatexp (PP LPARENleft RPARENright, Exp_) )
end)
 in ( LrTable.NT 69, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 127, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( _,
 (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => (
 RECORDatexp (PP LPARENleft RPARENright, NONE, NONE) ))
 in ( LrTable.NT 69, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 128, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.ExpComma_seq2 ExpComma_seq21, _, _)) :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = MlyValue.AtExp
 (fn _ => let val  (ExpComma_seq2 as ExpComma_seq21) = ExpComma_seq21
 ()
 in (
 tuple_atexp_with_info (PP LPARENleft RPARENright) ExpComma_seq2 NONE 
)
end)
 in ( LrTable.NT 69, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 129, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( _, _, 
RPARENright)) :: ( _, ( MlyValue.ExpComma_seq2 ExpComma_seq21, _, _))
 :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.AtExp (fn _ => let val  (ExpComma_seq2 as 
ExpComma_seq21) = ExpComma_seq21 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 tuple_atexp_with_info (PP LPARENleft RPARENright) ExpComma_seq2
                                                (SOME(PP BACKQUOTEleft EqIdentright,
                                                      RegVar.mk_Named EqIdent)) 
)
end)
 in ( LrTable.NT 69, ( result, LPAREN1left, EqIdent1right), rest671)

end
|  ( 130, ( ( _, ( MlyValue.Label Label1, _, (Labelright as 
Label1right))) :: ( _, ( _, (HASHleft as HASH1left), _)) :: rest671))
 => let val  result = MlyValue.AtExp (fn _ => let val  (Label as 
Label1) = Label1 ()
 in ( hash (PP HASHleft Labelright) Label )
end)
 in ( LrTable.NT 69, ( result, HASH1left, Label1right), rest671)
end
|  ( 131, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.ExpSemicolon_seq2 ExpSemicolon_seq21, _, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (ExpSemicolon_seq2 as 
ExpSemicolon_seq21) = ExpSemicolon_seq21 ()
 in (
 PARatexp (PP LPARENleft RPARENright,
                                   sequenceExp ExpSemicolon_seq2) 
)
end)
 in ( LrTable.NT 69, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 132, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.ExpSemicolon_seq2 ExpSemicolon_seq21, _, _)) :: _ :: ( _, ( 
MlyValue.Dec Dec1, _, _)) :: ( _, ( _, (LETleft as LET1left), _)) :: 
rest671)) => let val  result = MlyValue.AtExp (fn _ => let val  (Dec
 as Dec1) = Dec1 ()
 val  (ExpSemicolon_seq2 as ExpSemicolon_seq21) = ExpSemicolon_seq21
 ()
 in (
 LETatexp (PP LETleft ENDright,
				    Dec, sequenceExp ExpSemicolon_seq2) 
)
end)
 in ( LrTable.NT 69, ( result, LET1left, END1right), rest671)
end
|  ( 133, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.ExpComma_seq0 ExpComma_seq01, _, _)) :: ( _, ( _, (
LBRACKETleft as LBRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (ExpComma_seq0 as ExpComma_seq01) = 
ExpComma_seq01 ()
 in ( list_atexp (PP LBRACKETleft RBRACKETright) ExpComma_seq0 )
end)
 in ( LrTable.NT 69, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 134, ( ( _, ( MlyValue.AQID AQID1, (AQIDleft as AQID1left), (
AQIDright as AQID1right))) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (AQID as AQID1) = AQID1 ()
 in (
IDENTatexp (PP AQIDleft AQIDright,
					       OP_OPT (mk_LongId [AQID], false), NONE)
)
end)
 in ( LrTable.NT 69, ( result, AQID1left, AQID1right), rest671)
end
|  ( 135, ( ( _, ( MlyValue.Quote Quote1, (Quoteleft as Quote1left), (
Quoteright as Quote1right))) :: rest671)) => let val  result = 
MlyValue.AtExp (fn _ => let val  (Quote as Quote1) = Quote1 ()
 in ( list_atexp (PP Quoteleft Quoteright) Quote )
end)
 in ( LrTable.NT 69, ( result, Quote1left, Quote1right), rest671)
end
|  ( 136, ( ( _, ( MlyValue.ENDQ ENDQ1, _, (ENDQright as ENDQ1right)))
 :: ( _, ( _, (BEGINQleft as BEGINQ1left), _)) :: rest671)) => let
 val  result = MlyValue.Quote (fn _ => let val  (ENDQ as ENDQ1) = 
ENDQ1 ()
 in ([exp_quote (PP BEGINQleft ENDQright) ENDQ])
end)
 in ( LrTable.NT 93, ( result, BEGINQ1left, ENDQ1right), rest671)
end
|  ( 137, ( ( _, ( MlyValue.ENDQ ENDQ1, ENDQleft, (ENDQright as 
ENDQ1right))) :: ( _, ( MlyValue.OtList OtList1, _, _)) :: ( _, ( _, 
BEGINQ1left, _)) :: rest671)) => let val  result = MlyValue.Quote (fn
 _ => let val  (OtList as OtList1) = OtList1 ()
 val  (ENDQ as ENDQ1) = ENDQ1 ()
 in (OtList @ [exp_quote (PP ENDQleft ENDQright) ENDQ])
end)
 in ( LrTable.NT 93, ( result, BEGINQ1left, ENDQ1right), rest671)
end
|  ( 138, ( ( _, ( MlyValue.AtExp AtExp1, AtExpleft, (AtExpright as 
AtExp1right))) :: ( _, ( MlyValue.OBJL OBJL1, (OBJLleft as OBJL1left),
 OBJLright)) :: rest671)) => let val  result = MlyValue.OtList (fn _
 => let val  (OBJL as OBJL1) = OBJL1 ()
 val  (AtExp as AtExp1) = AtExp1 ()
 in (
[exp_quote (PP OBJLleft OBJLright) OBJL,
				   exp_antiquote (PP AtExpleft AtExpright) AtExp]
)
end)
 in ( LrTable.NT 94, ( result, OBJL1left, AtExp1right), rest671)
end
|  ( 139, ( ( _, ( MlyValue.OtList OtList1, _, OtList1right)) :: ( _, 
( MlyValue.AtExp AtExp1, AtExpleft, AtExpright)) :: ( _, ( 
MlyValue.OBJL OBJL1, (OBJLleft as OBJL1left), OBJLright)) :: rest671))
 => let val  result = MlyValue.OtList (fn _ => let val  (OBJL as OBJL1
) = OBJL1 ()
 val  (AtExp as AtExp1) = AtExp1 ()
 val  (OtList as OtList1) = OtList1 ()
 in (
exp_quote (PP OBJLleft OBJLright) OBJL ::
				   exp_antiquote (PP AtExpleft AtExpright) AtExp :: OtList
)
end)
 in ( LrTable.NT 94, ( result, OBJL1left, OtList1right), rest671)
end
|  ( 140, ( ( _, ( MlyValue.AtExp_seq1 AtExp_seq11, _, 
AtExp_seq11right)) :: ( _, ( MlyValue.AtExp AtExp1, AtExp1left, _)) ::
 rest671)) => let val  result = MlyValue.AtExp_seq1 (fn _ => let val 
 (AtExp as AtExp1) = AtExp1 ()
 val  (AtExp_seq1 as AtExp_seq11) = AtExp_seq11 ()
 in ( AtExp :: AtExp_seq1 )
end)
 in ( LrTable.NT 98, ( result, AtExp1left, AtExp_seq11right), rest671)

end
|  ( 141, ( ( _, ( MlyValue.AtExp AtExp1, AtExp1left, AtExp1right)) ::
 rest671)) => let val  result = MlyValue.AtExp_seq1 (fn _ => let val 
 (AtExp as AtExp1) = AtExp1 ()
 in ( [AtExp] )
end)
 in ( LrTable.NT 98, ( result, AtExp1left, AtExp1right), rest671)
end
|  ( 142, ( ( _, ( MlyValue.CommaExpRow_opt CommaExpRow_opt1, _, 
CommaExpRow_opt1right)) :: ( _, ( MlyValue.Exp_ Exp_1, _, _)) :: _ :: 
( _, ( MlyValue.Label Label1, (Labelleft as Label1left), _)) :: 
rest671)) => let val  result = MlyValue.ExpRow (fn _ => let val  (
Label as Label1) = Label1 ()
 val  (Exp_ as Exp_1) = Exp_1 ()
 val  (CommaExpRow_opt as CommaExpRow_opt1) = CommaExpRow_opt1 ()
 in (
 EXPROW (PP Labelleft
				    (rightmost get_info_exp Exp_
				               get_info_exprow CommaExpRow_opt),
				  Label, Exp_, CommaExpRow_opt) 
)
end)
 in ( LrTable.NT 68, ( result, Label1left, CommaExpRow_opt1right), 
rest671)
end
|  ( 143, ( ( _, ( MlyValue.ExpRow ExpRow1, ExpRow1left, ExpRow1right)
) :: rest671)) => let val  result = MlyValue.ExpRow_opt (fn _ => let
 val  (ExpRow as ExpRow1) = ExpRow1 ()
 in ( SOME ExpRow )
end)
 in ( LrTable.NT 81, ( result, ExpRow1left, ExpRow1right), rest671)

end
|  ( 144, ( rest671)) => let val  result = MlyValue.ExpRow_opt (fn _
 => ( NONE ))
 in ( LrTable.NT 81, ( result, defaultPos, defaultPos), rest671)
end
|  ( 145, ( ( _, ( MlyValue.ExpRow ExpRow1, _, ExpRow1right)) :: ( _, 
( _, COMMA1left, _)) :: rest671)) => let val  result = 
MlyValue.CommaExpRow_opt (fn _ => let val  (ExpRow as ExpRow1) = 
ExpRow1 ()
 in ( SOME ExpRow )
end)
 in ( LrTable.NT 71, ( result, COMMA1left, ExpRow1right), rest671)
end
|  ( 146, ( rest671)) => let val  result = MlyValue.CommaExpRow_opt
 (fn _ => ( NONE ))
 in ( LrTable.NT 71, ( result, defaultPos, defaultPos), rest671)
end
|  ( 147, ( ( _, ( MlyValue.ExpComma_seq1 ExpComma_seq11, 
ExpComma_seq11left, ExpComma_seq11right)) :: rest671)) => let val  
result = MlyValue.ExpComma_seq0 (fn _ => let val  (ExpComma_seq1 as 
ExpComma_seq11) = ExpComma_seq11 ()
 in ( ExpComma_seq1 )
end)
 in ( LrTable.NT 90, ( result, ExpComma_seq11left, ExpComma_seq11right
), rest671)
end
|  ( 148, ( rest671)) => let val  result = MlyValue.ExpComma_seq0 (fn
 _ => ( nil ))
 in ( LrTable.NT 90, ( result, defaultPos, defaultPos), rest671)
end
|  ( 149, ( ( _, ( MlyValue.ExpComma_seq1 ExpComma_seq11, _, 
ExpComma_seq11right)) :: _ :: ( _, ( MlyValue.Exp_ Exp_1, Exp_1left, _
)) :: rest671)) => let val  result = MlyValue.ExpComma_seq1 (fn _ =>
 let val  (Exp_ as Exp_1) = Exp_1 ()
 val  (ExpComma_seq1 as ExpComma_seq11) = ExpComma_seq11 ()
 in ( Exp_ :: ExpComma_seq1 )
end)
 in ( LrTable.NT 91, ( result, Exp_1left, ExpComma_seq11right), 
rest671)
end
|  ( 150, ( ( _, ( MlyValue.Exp_ Exp_1, Exp_1left, Exp_1right)) :: 
rest671)) => let val  result = MlyValue.ExpComma_seq1 (fn _ => let
 val  (Exp_ as Exp_1) = Exp_1 ()
 in ( [Exp_] )
end)
 in ( LrTable.NT 91, ( result, Exp_1left, Exp_1right), rest671)
end
|  ( 151, ( ( _, ( MlyValue.ExpComma_seq1 ExpComma_seq11, _, 
ExpComma_seq11right)) :: _ :: ( _, ( MlyValue.Exp_ Exp_1, Exp_1left, _
)) :: rest671)) => let val  result = MlyValue.ExpComma_seq2 (fn _ =>
 let val  (Exp_ as Exp_1) = Exp_1 ()
 val  (ExpComma_seq1 as ExpComma_seq11) = ExpComma_seq11 ()
 in ( Exp_ :: ExpComma_seq1 )
end)
 in ( LrTable.NT 92, ( result, Exp_1left, ExpComma_seq11right), 
rest671)
end
|  ( 152, ( ( _, ( MlyValue.ExpSemicolon_seq2 ExpSemicolon_seq21, _, 
ExpSemicolon_seq21right)) :: _ :: ( _, ( MlyValue.Exp_ Exp_1, 
Exp_1left, _)) :: rest671)) => let val  result = 
MlyValue.ExpSemicolon_seq2 (fn _ => let val  (Exp_ as Exp_1) = Exp_1
 ()
 val  (ExpSemicolon_seq2 as ExpSemicolon_seq21) = ExpSemicolon_seq21
 ()
 in ( Exp_ :: ExpSemicolon_seq2)
end)
 in ( LrTable.NT 101, ( result, Exp_1left, ExpSemicolon_seq21right), 
rest671)
end
|  ( 153, ( ( _, ( MlyValue.Exp_ Exp_2, _, Exp_2right)) :: _ :: ( _, (
 MlyValue.Exp_ Exp_1, Exp_1left, _)) :: rest671)) => let val  result =
 MlyValue.ExpSemicolon_seq2 (fn _ => let val  Exp_1 = Exp_1 ()
 val  Exp_2 = Exp_2 ()
 in ( [Exp_1, Exp_2] )
end)
 in ( LrTable.NT 101, ( result, Exp_1left, Exp_2right), rest671)
end
|  ( 154, ( ( _, ( MlyValue.AtExp_seq1 AtExp_seq11, (AtExp_seq1left
 as AtExp_seq11left), (AtExp_seq1right as AtExp_seq11right))) :: 
rest671)) => let val  result = MlyValue.Exp_ (fn _ => let val  (
AtExp_seq1 as AtExp_seq11) = AtExp_seq11 ()
 in ( UNRES_INFIXexp (PP AtExp_seq1left AtExp_seq1right, AtExp_seq1) )

end)
 in ( LrTable.NT 66, ( result, AtExp_seq11left, AtExp_seq11right), 
rest671)
end
|  ( 155, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: _ ::
 ( _, ( MlyValue.Exp_ Exp_1, (Exp_left as Exp_1left), _)) :: rest671))
 => let val  result = MlyValue.Exp_ (fn _ => let val  (Exp_ as Exp_1)
 = Exp_1 ()
 val  (Ty as Ty1) = Ty1 ()
 in ( TYPEDexp (PP Exp_left Tyright, Exp_, Ty) )
end)
 in ( LrTable.NT 66, ( result, Exp_1left, Ty1right), rest671)
end
|  ( 156, ( ( _, ( MlyValue.Match_ Match_1, _, Match_1right)) :: _ :: 
( _, ( MlyValue.Exp_ Exp_1, (Exp_left as Exp_1left), _)) :: rest671))
 => let val  result = MlyValue.Exp_ (fn _ => let val  (Exp_ as Exp_1)
 = Exp_1 ()
 val  (Match_ as Match_1) = Match_1 ()
 in (
 HANDLEexp (PP Exp_left (right (get_info_match Match_)),
				     Exp_, Match_) 
)
end)
 in ( LrTable.NT 66, ( result, Exp_1left, Match_1right), rest671)
end
|  ( 157, ( ( _, ( MlyValue.Exp_ Exp_1, _, Exp_1right)) :: ( _, ( _, (
RAISEleft as RAISE1left), _)) :: rest671)) => let val  result = 
MlyValue.Exp_ (fn _ => let val  (Exp_ as Exp_1) = Exp_1 ()
 in ( RAISEexp (PP RAISEleft (right (get_info_exp Exp_)), Exp_) )
end)
 in ( LrTable.NT 66, ( result, RAISE1left, Exp_1right), rest671)
end
|  ( 158, ( ( _, ( MlyValue.Match_ Match_1, _, Match_1right)) :: ( _, 
( _, (FNleft as FN1left), _)) :: rest671)) => let val  result = 
MlyValue.Exp_ (fn _ => let val  (Match_ as Match_1) = Match_1 ()
 in ( FNexp (PP FNleft (right (get_info_match Match_)), Match_) )
end)
 in ( LrTable.NT 66, ( result, FN1left, Match_1right), rest671)
end
|  ( 159, ( ( _, ( MlyValue.Match_ Match_1, _, Match_1right)) :: _ :: 
( _, ( MlyValue.Exp_ Exp_1, _, _)) :: ( _, ( _, (CASEleft as CASE1left
), _)) :: rest671)) => let val  result = MlyValue.Exp_ (fn _ => let
 val  (Exp_ as Exp_1) = Exp_1 ()
 val  (Match_ as Match_1) = Match_1 ()
 in (
 case_exp (PP CASEleft (right (get_info_match Match_)))
			    (Exp_, Match_) 
)
end)
 in ( LrTable.NT 66, ( result, CASE1left, Match_1right), rest671)
end
|  ( 160, ( ( _, ( MlyValue.Exp_ Exp_3, _, Exp_3right)) :: _ :: ( _, (
 MlyValue.Exp_ Exp_2, _, _)) :: _ :: ( _, ( MlyValue.Exp_ Exp_1, _, _)
) :: ( _, ( _, (IFleft as IF1left), _)) :: rest671)) => let val  
result = MlyValue.Exp_ (fn _ => let val  Exp_1 = Exp_1 ()
 val  Exp_2 = Exp_2 ()
 val  Exp_3 = Exp_3 ()
 in (
 if_then_else_exp (PP IFleft (right (get_info_exp Exp_3)))
			    (Exp_1, Exp_2, Exp_3) 
)
end)
 in ( LrTable.NT 66, ( result, IF1left, Exp_3right), rest671)
end
|  ( 161, ( ( _, ( MlyValue.Exp_ Exp_2, _, Exp_2right)) :: _ :: ( _, (
 MlyValue.Exp_ Exp_1, Exp_1left, _)) :: rest671)) => let val  result =
 MlyValue.Exp_ (fn _ => let val  Exp_1 = Exp_1 ()
 val  Exp_2 = Exp_2 ()
 in (
 let val info = PP Exp_1left (right (get_info_exp Exp_2))
			  in
			    if_then_else_exp info (Exp_1, exp_true info, Exp_2)
			  end 
)
end)
 in ( LrTable.NT 66, ( result, Exp_1left, Exp_2right), rest671)
end
|  ( 162, ( ( _, ( MlyValue.Exp_ Exp_2, _, Exp_2right)) :: _ :: ( _, (
 MlyValue.Exp_ Exp_1, Exp_1left, _)) :: rest671)) => let val  result =
 MlyValue.Exp_ (fn _ => let val  Exp_1 = Exp_1 ()
 val  Exp_2 = Exp_2 ()
 in (
 let val info = PP Exp_1left (right (get_info_exp Exp_2))
			  in
			    if_then_else_exp info (Exp_1, Exp_2, exp_false info)
			  end 
)
end)
 in ( LrTable.NT 66, ( result, Exp_1left, Exp_2right), rest671)
end
|  ( 163, ( ( _, ( MlyValue.Exp_ Exp_2, _, Exp_2right)) :: _ :: ( _, (
 MlyValue.Exp_ Exp_1, _, _)) :: ( _, ( _, (WHILEleft as WHILE1left), _
)) :: rest671)) => let val  result = MlyValue.Exp_ (fn _ => let val  
Exp_1 = Exp_1 ()
 val  Exp_2 = Exp_2 ()
 in (
 while_exp (PP WHILEleft (right (get_info_exp Exp_2)))
			    (Exp_1, Exp_2) 
)
end)
 in ( LrTable.NT 66, ( result, WHILE1left, Exp_2right), rest671)
end
|  ( 164, ( ( _, ( MlyValue.BarMatch_opt BarMatch_opt1, _, 
BarMatch_opt1right)) :: ( _, ( MlyValue.MRule MRule1, (MRuleleft as 
MRule1left), _)) :: rest671)) => let val  result = MlyValue.Match_ (fn
 _ => let val  (MRule as MRule1) = MRule1 ()
 val  (BarMatch_opt as BarMatch_opt1) = BarMatch_opt1 ()
 in (
 MATCH (PP MRuleleft
				   (rightmost get_info_mrule MRule
				              get_info_match BarMatch_opt),
				 MRule, BarMatch_opt) 
)
end)
 in ( LrTable.NT 67, ( result, MRule1left, BarMatch_opt1right), 
rest671)
end
|  ( 165, ( ( _, ( MlyValue.Match_ Match_1, _, Match_1right)) :: ( _, 
( _, BAR1left, _)) :: rest671)) => let val  result = 
MlyValue.BarMatch_opt (fn _ => let val  (Match_ as Match_1) = Match_1
 ()
 in ( SOME Match_ )
end)
 in ( LrTable.NT 79, ( result, BAR1left, Match_1right), rest671)
end
|  ( 166, ( rest671)) => let val  result = MlyValue.BarMatch_opt (fn _
 => ( NONE ))
 in ( LrTable.NT 79, ( result, defaultPos, defaultPos), rest671)
end
|  ( 167, ( ( _, ( MlyValue.Exp_ Exp_1, _, Exp_1right)) :: _ :: ( _, (
 MlyValue.Pat Pat1, (Patleft as Pat1left), _)) :: rest671)) => let
 val  result = MlyValue.MRule (fn _ => let val  (Pat as Pat1) = Pat1
 ()
 val  (Exp_ as Exp_1) = Exp_1 ()
 in ( MRULE (PP Patleft (right (get_info_exp Exp_)), Pat, Exp_) )
end)
 in ( LrTable.NT 65, ( result, Pat1left, Exp_1right), rest671)
end
|  ( 168, ( ( _, ( MlyValue.ValBind ValBind1, _, ValBind1right)) :: (
 _, ( _, (VALleft as VAL1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (ValBind as ValBind1) = 
ValBind1 ()
 in (
 VALdec (PP VALleft (right (get_info_valbind ValBind)),
				  [], ValBind) 
)
end)
 in ( LrTable.NT 114, ( result, VAL1left, ValBind1right), rest671)
end
|  ( 169, ( ( _, ( MlyValue.ValBind ValBind1, _, ValBind1right)) :: (
 _, ( MlyValue.TyVarSeq1 TyVarSeq11, _, _)) :: ( _, ( _, (VALleft as 
VAL1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (TyVarSeq1 as TyVarSeq11)
 = TyVarSeq11 ()
 val  (ValBind as ValBind1) = ValBind1 ()
 in (
 VALdec (PP VALleft (right (get_info_valbind ValBind)),
				  TyVarSeq1, ValBind) 
)
end)
 in ( LrTable.NT 114, ( result, VAL1left, ValBind1right), rest671)
end
|  ( 170, ( ( _, ( MlyValue.TypBind TypBind1, _, TypBind1right)) :: (
 _, ( _, (TYPEleft as TYPE1left), _)) :: rest671)) => let val  result
 = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (TypBind as TypBind1)
 = TypBind1 ()
 in (
 TYPEdec (PP TYPEleft (right (get_info_typbind TypBind)),
				   TypBind) 
)
end)
 in ( LrTable.NT 114, ( result, TYPE1left, TypBind1right), rest671)

end
|  ( 171, ( ( _, ( MlyValue.DatBind_zero_arity DatBind_zero_arity1, _,
 DatBind_zero_arity1right)) :: ( _, ( _, (DATATYPEleft as 
DATATYPE1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (DatBind_zero_arity as 
DatBind_zero_arity1) = DatBind_zero_arity1 ()
 in (
 DATATYPEdec (PP DATATYPEleft
				         (right (get_info_datbind DatBind_zero_arity)),
				       DatBind_zero_arity) 
)
end)
 in ( LrTable.NT 114, ( result, DATATYPE1left, 
DatBind_zero_arity1right), rest671)
end
|  ( 172, ( ( _, ( MlyValue.DatBind_nonzero_arity 
DatBind_nonzero_arity1, _, DatBind_nonzero_arity1right)) :: ( _, ( _,
 (DATATYPEleft as DATATYPE1left), _)) :: rest671)) => let val  result
 = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (DatBind_nonzero_arity
 as DatBind_nonzero_arity1) = DatBind_nonzero_arity1 ()
 in (
 DATATYPEdec(PP DATATYPEleft
				        (right (get_info_datbind DatBind_nonzero_arity)),
				      DatBind_nonzero_arity) 
)
end)
 in ( LrTable.NT 114, ( result, DATATYPE1left, 
DatBind_nonzero_arity1right), rest671)
end
|  ( 173, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, _, (
LongTypeIdentright as LongTypeIdent1right))) :: _ :: _ :: ( _, ( 
MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( _, DATATYPE1left, _))
 :: rest671)) => let val  result = MlyValue.OneDec_sans_LOCAL (fn _ =>
 let val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 in (
 DATATYPE_REPLICATIONdec
			    (PP DATATYPE1left LongTypeIdentright,
			     mk_TyCon TypeIdent, mk_LongTyCon LongTypeIdent) 
)
end)
 in ( LrTable.NT 114, ( result, DATATYPE1left, LongTypeIdent1right), 
rest671)
end
|  ( 174, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.Dec Dec1, _, _)) :: _ :: ( _, ( MlyValue.DatBind DatBind1, _,
 _)) :: ( _, ( _, (ABSTYPEleft as ABSTYPE1left), _)) :: rest671)) =>
 let val  result = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (
DatBind as DatBind1) = DatBind1 ()
 val  (Dec as Dec1) = Dec1 ()
 in ( ABSTYPEdec (PP ABSTYPEleft ENDright, DatBind, Dec) )
end)
 in ( LrTable.NT 114, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 175, ( ( _, ( MlyValue.ExBind ExBind1, _, ExBind1right)) :: ( _, 
( _, (EXCEPTIONleft as EXCEPTION1left), _)) :: rest671)) => let val  
result = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (ExBind as 
ExBind1) = ExBind1 ()
 in (
 EXCEPTIONdec (PP EXCEPTIONleft
					  (right (get_info_exbind ExBind)),
					ExBind) 
)
end)
 in ( LrTable.NT 114, ( result, EXCEPTION1left, ExBind1right), rest671
)
end
|  ( 176, ( ( _, ( MlyValue.LongIdent_seq1 LongIdent_seq11, _, (
LongIdent_seq1right as LongIdent_seq11right))) :: ( _, ( _, (OPENleft
 as OPEN1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (LongIdent_seq1 as 
LongIdent_seq11) = LongIdent_seq11 ()
 in (
 OPENdec (PP OPENleft LongIdent_seq1right,
				   wi_Convert mk_LongStrId LongIdent_seq1) 
)
end)
 in ( LrTable.NT 114, ( result, OPEN1left, LongIdent_seq11right), 
rest671)
end
|  ( 177, ( ( _, ( MlyValue.EqIdent_seq1 EqIdent_seq11, _, (
EqIdent_seq1right as EqIdent_seq11right))) :: ( _, ( 
MlyValue.DIGIT_opt DIGIT_opt1, _, _)) :: ( _, ( _, (INFIXleft as 
INFIX1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (DIGIT_opt as DIGIT_opt1)
 = DIGIT_opt1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 INFIXdec (PP INFIXleft EqIdent_seq1right,
				    DIGIT_opt, map mk_Id EqIdent_seq1) 
)
end)
 in ( LrTable.NT 114, ( result, INFIX1left, EqIdent_seq11right), 
rest671)
end
|  ( 178, ( ( _, ( MlyValue.EqIdent_seq1 EqIdent_seq11, _, (
EqIdent_seq1right as EqIdent_seq11right))) :: ( _, ( 
MlyValue.DIGIT_opt DIGIT_opt1, _, _)) :: ( _, ( _, (INFIXRleft as 
INFIXR1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (DIGIT_opt as DIGIT_opt1)
 = DIGIT_opt1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 INFIXRdec (PP INFIXRleft EqIdent_seq1right,
				     DIGIT_opt, map mk_Id EqIdent_seq1) 
)
end)
 in ( LrTable.NT 114, ( result, INFIXR1left, EqIdent_seq11right), 
rest671)
end
|  ( 179, ( ( _, ( MlyValue.EqIdent_seq1 EqIdent_seq11, _, (
EqIdent_seq1right as EqIdent_seq11right))) :: ( _, ( _, (NONFIXleft
 as NONFIX1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (EqIdent_seq1 as 
EqIdent_seq11) = EqIdent_seq11 ()
 in (
 NONFIXdec (PP NONFIXleft EqIdent_seq1right,
				     map mk_Id EqIdent_seq1) 
)
end)
 in ( LrTable.NT 114, ( result, NONFIX1left, EqIdent_seq11right), 
rest671)
end
|  ( 180, ( ( _, ( MlyValue.TypBind TypBind1, _, TypBind1right)) :: _
 :: ( _, ( MlyValue.DatBind_zero_arity DatBind_zero_arity1, _, _)) :: 
( _, ( _, (DATATYPEleft as DATATYPE1left), _)) :: rest671)) => let
 val  result = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (
DatBind_zero_arity as DatBind_zero_arity1) = DatBind_zero_arity1 ()
 val  (TypBind as TypBind1) = TypBind1 ()
 in (
 let val db = rewriteDatBind (DatBind_zero_arity, TypBind)
                          in
                            SEQdec (PP DATATYPEleft (right (get_info_typbind TypBind)),
				    DATATYPEdec
				      (get_info_datbind DatBind_zero_arity, db),
				    TYPEdec (get_info_typbind TypBind, TypBind))
                          end 
)
end)
 in ( LrTable.NT 114, ( result, DATATYPE1left, TypBind1right), rest671
)
end
|  ( 181, ( ( _, ( MlyValue.TypBind TypBind1, _, TypBind1right)) :: _
 :: ( _, ( MlyValue.DatBind_nonzero_arity DatBind_nonzero_arity1, _, _
)) :: ( _, ( _, (DATATYPEleft as DATATYPE1left), _)) :: rest671)) =>
 let val  result = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (
DatBind_nonzero_arity as DatBind_nonzero_arity1) = 
DatBind_nonzero_arity1 ()
 val  (TypBind as TypBind1) = TypBind1 ()
 in (
 let val db = rewriteDatBind (DatBind_nonzero_arity, TypBind)
                          in
                            SEQdec (PP DATATYPEleft (right (get_info_typbind TypBind)),
				    DATATYPEdec
				      (get_info_datbind DatBind_nonzero_arity, db),
				    TYPEdec (get_info_typbind TypBind, TypBind))
                          end 
)
end)
 in ( LrTable.NT 114, ( result, DATATYPE1left, TypBind1right), rest671
)
end
|  ( 182, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.Dec Dec1, _, _)) :: _ :: ( _, ( MlyValue.TypBind TypBind1, 
TypBindleft, _)) :: _ :: ( _, ( MlyValue.DatBind DatBind1, _, _)) :: (
 _, ( _, (ABSTYPEleft as ABSTYPE1left), _)) :: rest671)) => let val  
result = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (DatBind as 
DatBind1) = DatBind1 ()
 val  (TypBind as TypBind1) = TypBind1 ()
 val  (Dec as Dec1) = Dec1 ()
 in (
 let val db = rewriteDatBind (DatBind, TypBind)
                          in
                            ABSTYPEdec
			      (PP ABSTYPEleft ENDright, db,
			       SEQdec (PP TypBindleft (right (get_info_dec Dec)),
				       TYPEdec (get_info_typbind TypBind, TypBind),
				       Dec))
                          end 
)
end)
 in ( LrTable.NT 114, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 183, ( ( _, ( MlyValue.FValBind FValBind1, _, FValBind1right)) ::
 ( _, ( _, (FUNleft as FUN1left), _)) :: rest671)) => let val  result
 = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (FValBind as FValBind1
) = FValBind1 ()
 in (
 UNRES_FUNdec (PP FUNleft (right (get_info_FValBind FValBind)),
					[], FValBind) 
)
end)
 in ( LrTable.NT 114, ( result, FUN1left, FValBind1right), rest671)

end
|  ( 184, ( ( _, ( MlyValue.FValBind FValBind1, _, FValBind1right)) ::
 ( _, ( MlyValue.TyVarSeq1 TyVarSeq11, _, _)) :: ( _, ( _, (FUNleft
 as FUN1left), _)) :: rest671)) => let val  result = 
MlyValue.OneDec_sans_LOCAL (fn _ => let val  (TyVarSeq1 as TyVarSeq11)
 = TyVarSeq11 ()
 val  (FValBind as FValBind1) = FValBind1 ()
 in (
 UNRES_FUNdec (PP FUNleft (right (get_info_FValBind FValBind)),
					TyVarSeq1, FValBind) 
)
end)
 in ( LrTable.NT 114, ( result, FUN1left, FValBind1right), rest671)

end
|  ( 185, ( ( _, ( MlyValue.EqIdent_seq1 EqIdent_seq11, 
EqIdent_seq1left, (EqIdent_seq1right as EqIdent_seq11right))) :: ( _, 
( _, (REGIONleft as REGION1left), _)) :: rest671)) => let val  result
 = MlyValue.OneDec_sans_LOCAL (fn _ => let val  (EqIdent_seq1 as 
EqIdent_seq11) = EqIdent_seq11 ()
 in (
 REGIONdec (PP REGIONleft EqIdent_seq1right,
				     (PP EqIdent_seq1left EqIdent_seq1right,
                                      map RegVar.mk_Named EqIdent_seq1)) 
)
end)
 in ( LrTable.NT 114, ( result, REGION1left, EqIdent_seq11right), 
rest671)
end
|  ( 186, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.Dec Dec2, _, _)) :: _ :: ( _, ( MlyValue.Dec Dec1, _, _)) :: 
( _, ( _, (LOCALleft as LOCAL1left), _)) :: rest671)) => let val  
result = MlyValue.OneDec (fn _ => let val  Dec1 = Dec1 ()
 val  Dec2 = Dec2 ()
 in ( LOCALdec (PP LOCALleft ENDright, Dec1, Dec2) )
end)
 in ( LrTable.NT 113, ( result, LOCAL1left, END1right), rest671)
end
|  ( 187, ( ( _, ( MlyValue.OneDec_sans_LOCAL OneDec_sans_LOCAL1, 
OneDec_sans_LOCAL1left, OneDec_sans_LOCAL1right)) :: rest671)) => let
 val  result = MlyValue.OneDec (fn _ => let val  (OneDec_sans_LOCAL
 as OneDec_sans_LOCAL1) = OneDec_sans_LOCAL1 ()
 in ( OneDec_sans_LOCAL )
end)
 in ( LrTable.NT 113, ( result, OneDec_sans_LOCAL1left, 
OneDec_sans_LOCAL1right), rest671)
end
|  ( 188, ( ( _, ( MlyValue.OneDec OneDec1, OneDec1left, OneDec1right)
) :: rest671)) => let val  result = MlyValue.OneDec_or_SEMICOLON (fn _
 => let val  (OneDec as OneDec1) = OneDec1 ()
 in ( SOME OneDec )
end)
 in ( LrTable.NT 105, ( result, OneDec1left, OneDec1right), rest671)

end
|  ( 189, ( ( _, ( _, SEMICOLON1left, SEMICOLON1right)) :: rest671))
 => let val  result = MlyValue.OneDec_or_SEMICOLON (fn _ => ( NONE ))
 in ( LrTable.NT 105, ( result, SEMICOLON1left, SEMICOLON1right), 
rest671)
end
|  ( 190, ( ( _, ( MlyValue.OneDec_or_SEMICOLON OneDec_or_SEMICOLON1,
 _, OneDec_or_SEMICOLON1right)) :: ( _, ( MlyValue.NonEmptyDec 
NonEmptyDec1, (NonEmptyDecleft as NonEmptyDec1left), _)) :: rest671))
 => let val  result = MlyValue.NonEmptyDec (fn _ => let val  (
NonEmptyDec as NonEmptyDec1) = NonEmptyDec1 ()
 val  (OneDec_or_SEMICOLON as OneDec_or_SEMICOLON1) = 
OneDec_or_SEMICOLON1 ()
 in (
 (case OneDec_or_SEMICOLON of
			     SOME dec =>
			       composeDec (PP NonEmptyDecleft
					     (right (get_info_dec dec)),
					   NonEmptyDec, dec)
			   | NONE => NonEmptyDec) 
)
end)
 in ( LrTable.NT 106, ( result, NonEmptyDec1left, 
OneDec_or_SEMICOLON1right), rest671)
end
|  ( 191, ( ( _, ( MlyValue.OneDec_or_SEMICOLON OneDec_or_SEMICOLON1, 
OneDec_or_SEMICOLON1left, OneDec_or_SEMICOLON1right)) :: rest671)) =>
 let val  result = MlyValue.NonEmptyDec (fn _ => let val  (
OneDec_or_SEMICOLON as OneDec_or_SEMICOLON1) = OneDec_or_SEMICOLON1 ()
 in (
 (case OneDec_or_SEMICOLON of
			     SOME dec => dec
			   | NONE => EMPTYdec (PP defaultPos defaultPos)) 
)
end)
 in ( LrTable.NT 106, ( result, OneDec_or_SEMICOLON1left, 
OneDec_or_SEMICOLON1right), rest671)
end
|  ( 192, ( ( _, ( MlyValue.NonEmptyDec NonEmptyDec1, NonEmptyDec1left
, NonEmptyDec1right)) :: rest671)) => let val  result = MlyValue.Dec
 (fn _ => let val  (NonEmptyDec as NonEmptyDec1) = NonEmptyDec1 ()
 in ( NonEmptyDec )
end)
 in ( LrTable.NT 64, ( result, NonEmptyDec1left, NonEmptyDec1right), 
rest671)
end
|  ( 193, ( rest671)) => let val  result = MlyValue.Dec (fn _ => (
 EMPTYdec (PP defaultPos defaultPos) ))
 in ( LrTable.NT 64, ( result, defaultPos, defaultPos), rest671)
end
|  ( 194, ( ( _, ( MlyValue.AndValBind_opt AndValBind_opt1, _, 
AndValBind_opt1right)) :: ( _, ( MlyValue.Exp_ Exp_1, _, _)) :: _ :: (
 _, ( MlyValue.Pat Pat1, (Patleft as Pat1left), _)) :: rest671)) =>
 let val  result = MlyValue.ValBind (fn _ => let val  (Pat as Pat1) = 
Pat1 ()
 val  (Exp_ as Exp_1) = Exp_1 ()
 val  (AndValBind_opt as AndValBind_opt1) = AndValBind_opt1 ()
 in (
 PLAINvalbind (PP Patleft
					  (rightmost get_info_exp Exp_
					             get_info_valbind AndValBind_opt),
					Pat, Exp_, AndValBind_opt) 
)
end)
 in ( LrTable.NT 61, ( result, Pat1left, AndValBind_opt1right), 
rest671)
end
|  ( 195, ( ( _, ( MlyValue.FnValBind FnValBind1, _, FnValBind1right))
 :: ( _, ( _, (RECleft as REC1left), _)) :: rest671)) => let val  
result = MlyValue.ValBind (fn _ => let val  (FnValBind as FnValBind1)
 = FnValBind1 ()
 in (
 RECvalbind (PP RECleft
				        (right (get_info_valbind FnValBind)),
				      FnValBind) 
)
end)
 in ( LrTable.NT 61, ( result, REC1left, FnValBind1right), rest671)

end
|  ( 196, ( ( _, ( MlyValue.ValBind ValBind1, _, ValBind1right)) :: (
 _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndValBind_opt (fn _ => let val  (ValBind as ValBind1) = 
ValBind1 ()
 in ( SOME ValBind )
end)
 in ( LrTable.NT 72, ( result, AND1left, ValBind1right), rest671)
end
|  ( 197, ( rest671)) => let val  result = MlyValue.AndValBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 72, ( result, defaultPos, defaultPos), rest671)
end
|  ( 198, ( ( _, ( MlyValue.AndFnValBind_opt AndFnValBind_opt1, _, 
AndFnValBind_opt1right)) :: ( _, ( MlyValue.Match_ Match_1, _, _)) :: 
( _, ( _, FNleft, _)) :: _ :: ( _, ( MlyValue.Pat Pat1, (Patleft as 
Pat1left), _)) :: rest671)) => let val  result = MlyValue.FnValBind
 (fn _ => let val  (Pat as Pat1) = Pat1 ()
 val  (Match_ as Match_1) = Match_1 ()
 val  (AndFnValBind_opt as AndFnValBind_opt1) = AndFnValBind_opt1 ()
 in (
 PLAINvalbind
			    (PP Patleft
			       (rightmost get_info_match Match_
				          get_info_valbind AndFnValBind_opt),
			       Pat,
			       FNexp (PP FNleft (right (get_info_match Match_)), Match_),
			       AndFnValBind_opt) 
)
end)
 in ( LrTable.NT 62, ( result, Pat1left, AndFnValBind_opt1right), 
rest671)
end
|  ( 199, ( ( _, ( MlyValue.AndFnValBind_opt AndFnValBind_opt1, _, 
AndFnValBind_opt1right)) :: ( _, ( MlyValue.ColonTy_seq1 ColonTy_seq11
, _, ColonTy_seq1right)) :: ( _, ( _, _, RPARENright)) :: ( _, ( 
MlyValue.Match_ Match_1, _, _)) :: ( _, ( _, FNleft, _)) :: ( _, ( _, 
LPARENleft, _)) :: _ :: ( _, ( MlyValue.Pat Pat1, (Patleft as Pat1left
), _)) :: rest671)) => let val  result = MlyValue.FnValBind (fn _ =>
 let val  (Pat as Pat1) = Pat1 ()
 val  (Match_ as Match_1) = Match_1 ()
 val  (ColonTy_seq1 as ColonTy_seq11) = ColonTy_seq11 ()
 val  (AndFnValBind_opt as AndFnValBind_opt1) = AndFnValBind_opt1 ()
 in (
 let
                            val fnExp =
			          FNexp (PP FNleft (right (get_info_match Match_)), Match_)
                            val parAtexp =
                                  PARatexp (PP LPARENleft RPARENright, fnExp)
                            val atexpExp =
                                  ATEXPexp (PP LPARENleft RPARENright, parAtexp)

                            fun attachTypes (e, nil) = e
                              | attachTypes (e, (ty, p) :: rest) =
                                  attachTypes (TYPEDexp (PP FNleft p, e, ty), rest)
                          in
                            PLAINvalbind (PP Patleft
					    (rightmost' ColonTy_seq1right
					                get_info_valbind AndFnValBind_opt),
					  Pat,
					  attachTypes (atexpExp, ColonTy_seq1),
					  AndFnValBind_opt)
                          end 
)
end)
 in ( LrTable.NT 62, ( result, Pat1left, AndFnValBind_opt1right), 
rest671)
end
|  ( 200, ( ( _, ( MlyValue.FnValBind FnValBind1, _, FnValBind1right))
 :: ( _, ( _, (RECleft as REC1left), _)) :: rest671)) => let val  
result = MlyValue.FnValBind (fn _ => let val  (FnValBind as FnValBind1
) = FnValBind1 ()
 in (
 RECvalbind (PP RECleft
				        (right (get_info_valbind FnValBind)),
				      FnValBind) 
)
end)
 in ( LrTable.NT 62, ( result, REC1left, FnValBind1right), rest671)

end
|  ( 201, ( ( _, ( MlyValue.ColonTy_seq1 ColonTy_seq11, _, 
ColonTy_seq11right)) :: ( _, ( MlyValue.Ty Ty1, _, Tyright)) :: ( _, (
 _, COLON1left, _)) :: rest671)) => let val  result = 
MlyValue.ColonTy_seq1 (fn _ => let val  (Ty as Ty1) = Ty1 ()
 val  (ColonTy_seq1 as ColonTy_seq11) = ColonTy_seq11 ()
 in ( (Ty, Tyright) :: ColonTy_seq1 )
end)
 in ( LrTable.NT 86, ( result, COLON1left, ColonTy_seq11right), 
rest671)
end
|  ( 202, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: ( _,
 ( _, COLON1left, _)) :: rest671)) => let val  result = 
MlyValue.ColonTy_seq1 (fn _ => let val  (Ty as Ty1) = Ty1 ()
 in ( [(Ty, Tyright)] )
end)
 in ( LrTable.NT 86, ( result, COLON1left, Ty1right), rest671)
end
|  ( 203, ( ( _, ( MlyValue.FnValBind FnValBind1, _, FnValBind1right))
 :: ( _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndFnValBind_opt (fn _ => let val  (FnValBind as FnValBind1)
 = FnValBind1 ()
 in ( SOME FnValBind )
end)
 in ( LrTable.NT 73, ( result, AND1left, FnValBind1right), rest671)

end
|  ( 204, ( rest671)) => let val  result = MlyValue.AndFnValBind_opt
 (fn _ => ( NONE ))
 in ( LrTable.NT 73, ( result, defaultPos, defaultPos), rest671)
end
|  ( 205, ( ( _, ( MlyValue.AndTypBind_opt AndTypBind_opt1, _, 
AndTypBind_opt1right)) :: ( _, ( MlyValue.Ty Ty1, _, _)) :: _ :: ( _, 
( MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( MlyValue.TyVarSeq 
TyVarSeq1, (TyVarSeqleft as TyVarSeq1left), _)) :: rest671)) => let
 val  result = MlyValue.TypBind (fn _ => let val  (TyVarSeq as 
TyVarSeq1) = TyVarSeq1 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (Ty as Ty1) = Ty1 ()
 val  (AndTypBind_opt as AndTypBind_opt1) = AndTypBind_opt1 ()
 in (
 TYPBIND (PP TyVarSeqleft
				     (rightmost get_info_ty Ty
				                get_info_typbind AndTypBind_opt),
				   TyVarSeq, mk_TyCon TypeIdent, Ty, AndTypBind_opt) 
)
end)
 in ( LrTable.NT 60, ( result, TyVarSeq1left, AndTypBind_opt1right), 
rest671)
end
|  ( 206, ( ( _, ( MlyValue.TypBind TypBind1, _, TypBind1right)) :: (
 _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndTypBind_opt (fn _ => let val  (TypBind as TypBind1) = 
TypBind1 ()
 in ( SOME TypBind )
end)
 in ( LrTable.NT 76, ( result, AND1left, TypBind1right), rest671)
end
|  ( 207, ( rest671)) => let val  result = MlyValue.AndTypBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 76, ( result, defaultPos, defaultPos), rest671)
end
|  ( 208, ( ( _, ( MlyValue.AndDatBind_opt AndDatBind_opt1, _, 
AndDatBind_opt1right)) :: ( _, ( MlyValue.ConBind ConBind1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( 
MlyValue.TyVarSeq TyVarSeq1, (TyVarSeqleft as TyVarSeq1left), _)) :: 
rest671)) => let val  result = MlyValue.DatBind (fn _ => let val  (
TyVarSeq as TyVarSeq1) = TyVarSeq1 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (ConBind as ConBind1) = ConBind1 ()
 val  (AndDatBind_opt as AndDatBind_opt1) = AndDatBind_opt1 ()
 in (
 DATBIND (PP TyVarSeqleft
				     (rightmost get_info_conbind ConBind
				                get_info_datbind AndDatBind_opt),
				   TyVarSeq, mk_TyCon TypeIdent,
				   ConBind, AndDatBind_opt) 
)
end)
 in ( LrTable.NT 57, ( result, TyVarSeq1left, AndDatBind_opt1right), 
rest671)
end
|  ( 209, ( ( _, ( MlyValue.AndDatBind_opt AndDatBind_opt1, _, 
AndDatBind_opt1right)) :: ( _, ( MlyValue.ConBind ConBind1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, (TypeIdentleft as 
TypeIdent1left), _)) :: rest671)) => let val  result = 
MlyValue.DatBind_zero_arity (fn _ => let val  (TypeIdent as TypeIdent1
) = TypeIdent1 ()
 val  (ConBind as ConBind1) = ConBind1 ()
 val  (AndDatBind_opt as AndDatBind_opt1) = AndDatBind_opt1 ()
 in (
 DATBIND (PP TypeIdentleft
				     (rightmost get_info_conbind ConBind
				                get_info_datbind AndDatBind_opt),
				   [], mk_TyCon TypeIdent,
				   ConBind, AndDatBind_opt) 
)
end)
 in ( LrTable.NT 58, ( result, TypeIdent1left, AndDatBind_opt1right), 
rest671)
end
|  ( 210, ( ( _, ( MlyValue.AndDatBind_opt AndDatBind_opt1, _, 
AndDatBind_opt1right)) :: ( _, ( MlyValue.ConBind ConBind1, _, _)) ::
 _ :: ( _, ( MlyValue.TypeIdent TypeIdent1, _, _)) :: ( _, ( 
MlyValue.TyVarSeq1 TyVarSeq11, (TyVarSeq1left as TyVarSeq11left), _))
 :: rest671)) => let val  result = MlyValue.DatBind_nonzero_arity (fn
 _ => let val  (TyVarSeq1 as TyVarSeq11) = TyVarSeq11 ()
 val  (TypeIdent as TypeIdent1) = TypeIdent1 ()
 val  (ConBind as ConBind1) = ConBind1 ()
 val  (AndDatBind_opt as AndDatBind_opt1) = AndDatBind_opt1 ()
 in (
 DATBIND (PP TyVarSeq1left
				     (rightmost get_info_conbind ConBind
				                get_info_datbind AndDatBind_opt),
				   TyVarSeq1, mk_TyCon TypeIdent,
				   ConBind, AndDatBind_opt) 
)
end)
 in ( LrTable.NT 59, ( result, TyVarSeq11left, AndDatBind_opt1right), 
rest671)
end
|  ( 211, ( ( _, ( MlyValue.DatBind DatBind1, _, DatBind1right)) :: (
 _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndDatBind_opt (fn _ => let val  (DatBind as DatBind1) = 
DatBind1 ()
 in ( SOME DatBind )
end)
 in ( LrTable.NT 77, ( result, AND1left, DatBind1right), rest671)
end
|  ( 212, ( rest671)) => let val  result = MlyValue.AndDatBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 77, ( result, defaultPos, defaultPos), rest671)
end
|  ( 213, ( ( _, ( MlyValue.BarConBind_opt BarConBind_opt1, _, 
BarConBind_opt1right)) :: ( _, ( MlyValue.OfTy_opt OfTy_opt1, _, _))
 :: ( _, ( MlyValue.OpIdent OpIdent1, (OpIdentleft as OpIdent1left), 
OpIdentright)) :: rest671)) => let val  result = MlyValue.ConBind (fn
 _ => let val  (OpIdent as OpIdent1) = OpIdent1 ()
 val  (OfTy_opt as OfTy_opt1) = OfTy_opt1 ()
 val  (BarConBind_opt as BarConBind_opt1) = BarConBind_opt1 ()
 in (
 let val OP_OPT (id, withOp) = OpIdent
                          in
                            CONBIND (PP OpIdentleft
				       (rightmost_of_three OpIdentright
					  get_info_ty OfTy_opt
					  get_info_conbind BarConBind_opt),
				     OP_OPT (mk_Id id, withOp),
				     OfTy_opt, BarConBind_opt)
                          end 
)
end)
 in ( LrTable.NT 56, ( result, OpIdent1left, BarConBind_opt1right), 
rest671)
end
|  ( 214, ( ( _, ( MlyValue.ConBind ConBind1, _, ConBind1right)) :: (
 _, ( _, BAR1left, _)) :: rest671)) => let val  result = 
MlyValue.BarConBind_opt (fn _ => let val  (ConBind as ConBind1) = 
ConBind1 ()
 in ( SOME ConBind )
end)
 in ( LrTable.NT 78, ( result, BAR1left, ConBind1right), rest671)
end
|  ( 215, ( rest671)) => let val  result = MlyValue.BarConBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 78, ( result, defaultPos, defaultPos), rest671)
end
|  ( 216, ( ( _, ( MlyValue.AndExBind_opt AndExBind_opt1, _, 
AndExBind_opt1right)) :: ( _, ( MlyValue.OfTy_opt OfTy_opt1, _, _)) ::
 ( _, ( MlyValue.OpIdent OpIdent1, (OpIdentleft as OpIdent1left), 
OpIdentright)) :: rest671)) => let val  result = MlyValue.ExBind (fn _
 => let val  (OpIdent as OpIdent1) = OpIdent1 ()
 val  (OfTy_opt as OfTy_opt1) = OfTy_opt1 ()
 val  (AndExBind_opt as AndExBind_opt1) = AndExBind_opt1 ()
 in (
 let val OP_OPT (id, withOp) = OpIdent
                          in
                            EXBIND (PP OpIdentleft
				      (rightmost_of_three OpIdentright
					  get_info_ty OfTy_opt
					  get_info_exbind AndExBind_opt),
				    OP_OPT (mk_Id id, withOp),
				    OfTy_opt, AndExBind_opt)
                          end 
)
end)
 in ( LrTable.NT 55, ( result, OpIdent1left, AndExBind_opt1right), 
rest671)
end
|  ( 217, ( ( _, ( MlyValue.AndExBind_opt AndExBind_opt1, _, 
AndExBind_opt1right)) :: ( _, ( MlyValue.LongOpEqIdent LongOpEqIdent1,
 _, LongOpEqIdentright)) :: _ :: ( _, ( MlyValue.OpIdent OpIdent1, (
OpIdentleft as OpIdent1left), _)) :: rest671)) => let val  result = 
MlyValue.ExBind (fn _ => let val  (OpIdent as OpIdent1) = OpIdent1 ()
 val  (LongOpEqIdent as LongOpEqIdent1) = LongOpEqIdent1 ()
 val  (AndExBind_opt as AndExBind_opt1) = AndExBind_opt1 ()
 in (
 let val OP_OPT (id1, withOp1) = OpIdent
			      val OP_OPT (id2, withOp2) = LongOpEqIdent
                          in
                            EXEQUAL (PP OpIdentleft
				       (rightmost' LongOpEqIdentright
					  get_info_exbind AndExBind_opt),
				     OP_OPT (mk_Id id1, withOp1),
				     OP_OPT (mk_LongId id2, withOp2),
				     AndExBind_opt)
                          end 
)
end)
 in ( LrTable.NT 55, ( result, OpIdent1left, AndExBind_opt1right), 
rest671)
end
|  ( 218, ( ( _, ( MlyValue.ExBind ExBind1, _, ExBind1right)) :: ( _, 
( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndExBind_opt (fn _ => let val  (ExBind as ExBind1) = ExBind1
 ()
 in ( SOME ExBind )
end)
 in ( LrTable.NT 80, ( result, AND1left, ExBind1right), rest671)
end
|  ( 219, ( rest671)) => let val  result = MlyValue.AndExBind_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 80, ( result, defaultPos, defaultPos), rest671)
end
|  ( 220, ( ( _, ( MlyValue.AndFValBind_opt AndFValBind_opt1, _, 
AndFValBind_opt1right)) :: ( _, ( MlyValue.FClause FClause1, (
FClauseleft as FClause1left), _)) :: rest671)) => let val  result = 
MlyValue.FValBind (fn _ => let val  (FClause as FClause1) = FClause1
 ()
 val  (AndFValBind_opt as AndFValBind_opt1) = AndFValBind_opt1 ()
 in (
 FVALBIND (PP FClauseleft
				      (rightmost get_info_FClause FClause
				                 get_info_FValBind AndFValBind_opt),
				    FClause, AndFValBind_opt) 
)
end)
 in ( LrTable.NT 63, ( result, FClause1left, AndFValBind_opt1right), 
rest671)
end
|  ( 221, ( ( _, ( MlyValue.FValBind FValBind1, _, FValBind1right)) ::
 ( _, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AndFValBind_opt (fn _ => let val  (FValBind as FValBind1) = 
FValBind1 ()
 in ( SOME FValBind )
end)
 in ( LrTable.NT 74, ( result, AND1left, FValBind1right), rest671)
end
|  ( 222, ( rest671)) => let val  result = MlyValue.AndFValBind_opt
 (fn _ => ( NONE ))
 in ( LrTable.NT 74, ( result, defaultPos, defaultPos), rest671)
end
|  ( 223, ( ( _, ( MlyValue.BarFClause_opt BarFClause_opt1, _, 
BarFClause_opt1right)) :: ( _, ( MlyValue.Exp_ Exp_1, _, _)) :: _ :: (
 _, ( MlyValue.ColonTy_opt ColonTy_opt1, _, _)) :: ( _, ( 
MlyValue.AtPat_seq1 AtPat_seq11, (AtPat_seq1left as AtPat_seq11left),
 _)) :: rest671)) => let val  result = MlyValue.FClause (fn _ => let
 val  (AtPat_seq1 as AtPat_seq11) = AtPat_seq11 ()
 val  (ColonTy_opt as ColonTy_opt1) = ColonTy_opt1 ()
 val  (Exp_ as Exp_1) = Exp_1 ()
 val  (BarFClause_opt as BarFClause_opt1) = BarFClause_opt1 ()
 in (
 FCLAUSE (PP AtPat_seq1left
				     (rightmost get_info_exp Exp_
				                get_info_FClause BarFClause_opt),
				   AtPat_seq1, ColonTy_opt,
				   Exp_, BarFClause_opt) 
)
end)
 in ( LrTable.NT 70, ( result, AtPat_seq11left, BarFClause_opt1right),
 rest671)
end
|  ( 224, ( ( _, ( MlyValue.FClause FClause1, _, FClause1right)) :: (
 _, ( _, BAR1left, _)) :: rest671)) => let val  result = 
MlyValue.BarFClause_opt (fn _ => let val  (FClause as FClause1) = 
FClause1 ()
 in ( SOME FClause )
end)
 in ( LrTable.NT 75, ( result, BAR1left, FClause1right), rest671)
end
|  ( 225, ( rest671)) => let val  result = MlyValue.BarFClause_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 75, ( result, defaultPos, defaultPos), rest671)
end
|  ( 226, ( ( _, ( MlyValue.AtPat_seq1 AtPat_seq11, _, 
AtPat_seq11right)) :: ( _, ( MlyValue.AtPat AtPat1, AtPat1left, _)) ::
 rest671)) => let val  result = MlyValue.AtPat_seq2 (fn _ => let val 
 (AtPat as AtPat1) = AtPat1 ()
 val  (AtPat_seq1 as AtPat_seq11) = AtPat_seq11 ()
 in ( AtPat :: AtPat_seq1 )
end)
 in ( LrTable.NT 99, ( result, AtPat1left, AtPat_seq11right), rest671)

end
|  ( 227, ( ( _, ( MlyValue.AtPat_seq1 AtPat_seq11, _, 
AtPat_seq11right)) :: ( _, ( MlyValue.AtPat AtPat1, AtPat1left, _)) ::
 rest671)) => let val  result = MlyValue.AtPat_seq1 (fn _ => let val 
 (AtPat as AtPat1) = AtPat1 ()
 val  (AtPat_seq1 as AtPat_seq11) = AtPat_seq11 ()
 in ( AtPat :: AtPat_seq1 )
end)
 in ( LrTable.NT 100, ( result, AtPat1left, AtPat_seq11right), rest671
)
end
|  ( 228, ( ( _, ( MlyValue.AtPat AtPat1, AtPat1left, AtPat1right)) ::
 rest671)) => let val  result = MlyValue.AtPat_seq1 (fn _ => let val 
 (AtPat as AtPat1) = AtPat1 ()
 in ( [AtPat] )
end)
 in ( LrTable.NT 100, ( result, AtPat1left, AtPat1right), rest671)
end
|  ( 229, ( ( _, ( MlyValue.Ty Ty1, _, Ty1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = MlyValue.ColonTy_opt
 (fn _ => let val  (Ty as Ty1) = Ty1 ()
 in ( SOME Ty )
end)
 in ( LrTable.NT 85, ( result, COLON1left, Ty1right), rest671)
end
|  ( 230, ( rest671)) => let val  result = MlyValue.ColonTy_opt (fn _
 => ( NONE ))
 in ( LrTable.NT 85, ( result, defaultPos, defaultPos), rest671)
end
|  ( 231, ( ( _, ( MlyValue.Ty Ty1, _, Ty1right)) :: ( _, ( _, OF1left
, _)) :: rest671)) => let val  result = MlyValue.OfTy_opt (fn _ => let
 val  (Ty as Ty1) = Ty1 ()
 in ( SOME Ty )
end)
 in ( LrTable.NT 89, ( result, OF1left, Ty1right), rest671)
end
|  ( 232, ( rest671)) => let val  result = MlyValue.OfTy_opt (fn _ =>
 ( NONE ))
 in ( LrTable.NT 89, ( result, defaultPos, defaultPos), rest671)
end
|  ( 233, ( ( _, ( _, (UNDERBARleft as UNDERBAR1left), (UNDERBARright
 as UNDERBAR1right))) :: rest671)) => let val  result = MlyValue.AtPat
 (fn _ => ( WILDCARDatpat (PP UNDERBARleft UNDERBARright) ))
 in ( LrTable.NT 54, ( result, UNDERBAR1left, UNDERBAR1right), rest671
)
end
|  ( 234, ( ( _, ( MlyValue.SCon SCon1, (SConleft as SCon1left), (
SConright as SCon1right))) :: rest671)) => let val  result = 
MlyValue.AtPat (fn _ => let val  (SCon as SCon1) = SCon1 ()
 in ( SCONatpat (PP SConleft SConright, SCon) )
end)
 in ( LrTable.NT 54, ( result, SCon1left, SCon1right), rest671)
end
|  ( 235, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, _, _)) :: _ :: ( _, ( _, 
BACKQUOTEleft, _)) :: ( _, ( MlyValue.LongOpIdent LongOpIdent1, (
LongOpIdentleft as LongOpIdent1left), LongOpIdentright)) :: rest671))
 => let val  result = MlyValue.AtPat (fn _ => let val  (LongOpIdent
 as LongOpIdent1) = LongOpIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 let val OP_OPT (id, withOp) = LongOpIdent
                          in
                            LONGIDatpat (PP LongOpIdentleft LongOpIdentright,
					 OP_OPT (mk_LongId id, withOp),
                                         SOME (PP BACKQUOTEleft RBRACKETright,
                                               map RegVar.mk_Named EqIdent_seq1))
                          end 
)
end)
 in ( LrTable.NT 54, ( result, LongOpIdent1left, RBRACKET1right), 
rest671)
end
|  ( 236, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( 
MlyValue.LongOpIdent LongOpIdent1, (LongOpIdentleft as 
LongOpIdent1left), LongOpIdentright)) :: rest671)) => let val  result
 = MlyValue.AtPat (fn _ => let val  (LongOpIdent as LongOpIdent1) = 
LongOpIdent1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 let val OP_OPT (id, withOp) = LongOpIdent
                          in
                            LONGIDatpat (PP LongOpIdentleft LongOpIdentright,
					 OP_OPT (mk_LongId id, withOp),
                                         SOME (PP BACKQUOTEleft EqIdentright,
                                               [RegVar.mk_Named EqIdent]))
                          end 
)
end)
 in ( LrTable.NT 54, ( result, LongOpIdent1left, EqIdent1right), 
rest671)
end
|  ( 237, ( ( _, ( MlyValue.LongOpIdent LongOpIdent1, (LongOpIdentleft
 as LongOpIdent1left), (LongOpIdentright as LongOpIdent1right))) :: 
rest671)) => let val  result = MlyValue.AtPat (fn _ => let val  (
LongOpIdent as LongOpIdent1) = LongOpIdent1 ()
 in (
 let val OP_OPT (id, withOp) = LongOpIdent
                          in
                            LONGIDatpat (PP LongOpIdentleft LongOpIdentright,
					 OP_OPT (mk_LongId id, withOp), NONE)
                          end 
)
end)
 in ( LrTable.NT 54, ( result, LongOpIdent1left, LongOpIdent1right), 
rest671)
end
|  ( 238, ( ( _, ( _, _, (EQUALSright as EQUALS1right))) :: ( _, ( _,
 (OPleft as OP1left), _)) :: rest671)) => let val  result = 
MlyValue.AtPat (fn _ => (
 LONGIDatpat (PP OPleft EQUALSright,
				       OP_OPT (mk_LongId ["="], true), NONE) 
))
 in ( LrTable.NT 54, ( result, OP1left, EQUALS1right), rest671)
end
|  ( 239, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.PatRow_opt PatRow_opt1, _, _)) :: ( _, ( _, (LBRACEleft as 
LBRACE1left), _)) :: rest671)) => let val  result = MlyValue.AtPat (fn
 _ => let val  (PatRow_opt as PatRow_opt1) = PatRow_opt1 ()
 in ( RECORDatpat (PP LBRACEleft RBRACEright, PatRow_opt) )
end)
 in ( LrTable.NT 54, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 240, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.Pat Pat1, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)
) :: rest671)) => let val  result = MlyValue.AtPat (fn _ => let val  (
Pat as Pat1) = Pat1 ()
 in ( PARatpat (PP LPARENleft RPARENright, Pat) )
end)
 in ( LrTable.NT 54, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 241, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( _,
 (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.AtPat (fn _ => (
 RECORDatpat (PP LPARENleft RPARENright, NONE) ))
 in ( LrTable.NT 54, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 242, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.PatComma_seq2 PatComma_seq21, _, _)) :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = MlyValue.AtPat
 (fn _ => let val  (PatComma_seq2 as PatComma_seq21) = PatComma_seq21
 ()
 in ( tuple_atpat_with_info (PP LPARENleft RPARENright) PatComma_seq2 
)
end)
 in ( LrTable.NT 54, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 243, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.PatComma_seq0 PatComma_seq01, _, _)) :: ( _, ( _, (
LBRACKETleft as LBRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.AtPat (fn _ => let val  (PatComma_seq0 as PatComma_seq01) = 
PatComma_seq01 ()
 in ( list_atpat (PP LBRACKETleft RBRACKETright) PatComma_seq0 )
end)
 in ( LrTable.NT 54, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 244, ( ( _, ( MlyValue.PatRow PatRow1, PatRow1left, PatRow1right)
) :: rest671)) => let val  result = MlyValue.PatRow_opt (fn _ => let
 val  (PatRow as PatRow1) = PatRow1 ()
 in ( SOME PatRow )
end)
 in ( LrTable.NT 82, ( result, PatRow1left, PatRow1right), rest671)

end
|  ( 245, ( rest671)) => let val  result = MlyValue.PatRow_opt (fn _
 => ( NONE ))
 in ( LrTable.NT 82, ( result, defaultPos, defaultPos), rest671)
end
|  ( 246, ( ( _, ( _, (DOTDOTDOTleft as DOTDOTDOT1left), (
DOTDOTDOTright as DOTDOTDOT1right))) :: rest671)) => let val  result =
 MlyValue.PatRow (fn _ => (
 DecGrammar.DOTDOTDOT (PP DOTDOTDOTleft DOTDOTDOTright) ))
 in ( LrTable.NT 53, ( result, DOTDOTDOT1left, DOTDOTDOT1right), 
rest671)
end
|  ( 247, ( ( _, ( MlyValue.CommaPatRow_opt CommaPatRow_opt1, _, 
CommaPatRow_opt1right)) :: ( _, ( MlyValue.Pat Pat1, _, _)) :: _ :: (
 _, ( MlyValue.Label Label1, (Labelleft as Label1left), _)) :: rest671
)) => let val  result = MlyValue.PatRow (fn _ => let val  (Label as 
Label1) = Label1 ()
 val  (Pat as Pat1) = Pat1 ()
 val  (CommaPatRow_opt as CommaPatRow_opt1) = CommaPatRow_opt1 ()
 in (
 PATROW (PP Labelleft
				    (rightmost get_info_pat Pat
				               get_info_patrow CommaPatRow_opt),
				  Label, Pat, CommaPatRow_opt) 
)
end)
 in ( LrTable.NT 53, ( result, Label1left, CommaPatRow_opt1right), 
rest671)
end
|  ( 248, ( ( _, ( MlyValue.CommaPatRow_opt CommaPatRow_opt1, _, 
CommaPatRow_opt1right)) :: ( _, ( MlyValue.AsPat_opt AsPat_opt1, _, _)
) :: ( _, ( MlyValue.ColonTy_opt ColonTy_opt1, _, _)) :: ( _, ( 
MlyValue.Ident Ident1, (Identleft as Ident1left), Identright)) :: 
rest671)) => let val  result = MlyValue.PatRow (fn _ => let val  (
Ident as Ident1) = Ident1 ()
 val  (ColonTy_opt as ColonTy_opt1) = ColonTy_opt1 ()
 val  (AsPat_opt as AsPat_opt1) = AsPat_opt1 ()
 val  (CommaPatRow_opt as CommaPatRow_opt1) = CommaPatRow_opt1 ()
 in (
 PATROW
			    (PP Identleft
			       (rightmost_of_four Identright
				  get_info_ty ColonTy_opt
				  get_info_pat AsPat_opt
				  get_info_patrow CommaPatRow_opt),
			     mk_IdentLab Ident,
			     let
			       val info_ident = PP Identleft Identright
			       val idPat =
				     ATPATpat
				       (info_ident,
					LONGIDatpat
					  (info_ident, OP_OPT (mk_LongId [Ident], false), NONE))
			     in
			       case (ColonTy_opt, AsPat_opt) of
				 (_, SOME pat) =>
				   LAYEREDpat (PP Identleft (right (get_info_pat pat)),
					       OP_OPT (mk_Id Ident, false),
					       ColonTy_opt, pat)
			       | (SOME ty, NONE) =>
				   TYPEDpat (PP Identleft (right (get_info_ty ty)),
					     idPat, ty)
			       | (NONE, NONE) => idPat
			     end,
			     CommaPatRow_opt) 
)
end)
 in ( LrTable.NT 53, ( result, Ident1left, CommaPatRow_opt1right), 
rest671)
end
|  ( 249, ( ( _, ( MlyValue.Pat Pat1, _, Pat1right)) :: ( _, ( _, 
AS1left, _)) :: rest671)) => let val  result = MlyValue.AsPat_opt (fn
 _ => let val  (Pat as Pat1) = Pat1 ()
 in ( SOME Pat )
end)
 in ( LrTable.NT 83, ( result, AS1left, Pat1right), rest671)
end
|  ( 250, ( rest671)) => let val  result = MlyValue.AsPat_opt (fn _ =>
 ( NONE ))
 in ( LrTable.NT 83, ( result, defaultPos, defaultPos), rest671)
end
|  ( 251, ( ( _, ( MlyValue.PatRow PatRow1, _, PatRow1right)) :: ( _, 
( _, COMMA1left, _)) :: rest671)) => let val  result = 
MlyValue.CommaPatRow_opt (fn _ => let val  (PatRow as PatRow1) = 
PatRow1 ()
 in ( SOME PatRow )
end)
 in ( LrTable.NT 84, ( result, COMMA1left, PatRow1right), rest671)
end
|  ( 252, ( rest671)) => let val  result = MlyValue.CommaPatRow_opt
 (fn _ => ( NONE ))
 in ( LrTable.NT 84, ( result, defaultPos, defaultPos), rest671)
end
|  ( 253, ( ( _, ( MlyValue.PatComma_seq1 PatComma_seq11, 
PatComma_seq11left, PatComma_seq11right)) :: rest671)) => let val  
result = MlyValue.PatComma_seq0 (fn _ => let val  (PatComma_seq1 as 
PatComma_seq11) = PatComma_seq11 ()
 in ( PatComma_seq1 )
end)
 in ( LrTable.NT 95, ( result, PatComma_seq11left, PatComma_seq11right
), rest671)
end
|  ( 254, ( rest671)) => let val  result = MlyValue.PatComma_seq0 (fn
 _ => ( nil ))
 in ( LrTable.NT 95, ( result, defaultPos, defaultPos), rest671)
end
|  ( 255, ( ( _, ( MlyValue.PatComma_seq1 PatComma_seq11, _, 
PatComma_seq11right)) :: _ :: ( _, ( MlyValue.Pat Pat1, Pat1left, _))
 :: rest671)) => let val  result = MlyValue.PatComma_seq1 (fn _ => let
 val  (Pat as Pat1) = Pat1 ()
 val  (PatComma_seq1 as PatComma_seq11) = PatComma_seq11 ()
 in ( Pat :: PatComma_seq1 )
end)
 in ( LrTable.NT 96, ( result, Pat1left, PatComma_seq11right), rest671
)
end
|  ( 256, ( ( _, ( MlyValue.Pat Pat1, Pat1left, Pat1right)) :: rest671
)) => let val  result = MlyValue.PatComma_seq1 (fn _ => let val  (Pat
 as Pat1) = Pat1 ()
 in ( [Pat] )
end)
 in ( LrTable.NT 96, ( result, Pat1left, Pat1right), rest671)
end
|  ( 257, ( ( _, ( MlyValue.PatComma_seq1 PatComma_seq11, _, 
PatComma_seq11right)) :: _ :: ( _, ( MlyValue.Pat Pat1, Pat1left, _))
 :: rest671)) => let val  result = MlyValue.PatComma_seq2 (fn _ => let
 val  (Pat as Pat1) = Pat1 ()
 val  (PatComma_seq1 as PatComma_seq11) = PatComma_seq11 ()
 in ( Pat :: PatComma_seq1 )
end)
 in ( LrTable.NT 97, ( result, Pat1left, PatComma_seq11right), rest671
)
end
|  ( 258, ( ( _, ( MlyValue.AtPat AtPat1, AtPat1left, AtPat1right)) ::
 rest671)) => let val  result = MlyValue.Pat (fn _ => let val  (AtPat
 as AtPat1) = AtPat1 ()
 in ( ATPATpat (get_info_atpat AtPat, AtPat) )
end)
 in ( LrTable.NT 52, ( result, AtPat1left, AtPat1right), rest671)
end
|  ( 259, ( ( _, ( MlyValue.AtPat_seq2 AtPat_seq21, (AtPat_seq2left
 as AtPat_seq21left), (AtPat_seq2right as AtPat_seq21right))) :: 
rest671)) => let val  result = MlyValue.Pat (fn _ => let val  (
AtPat_seq2 as AtPat_seq21) = AtPat_seq21 ()
 in (
 UNRES_INFIXpat (PP AtPat_seq2left AtPat_seq2right,
					  AtPat_seq2) 
)
end)
 in ( LrTable.NT 52, ( result, AtPat_seq21left, AtPat_seq21right), 
rest671)
end
|  ( 260, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: _ ::
 ( _, ( MlyValue.Pat Pat1, (Patleft as Pat1left), _)) :: rest671)) =>
 let val  result = MlyValue.Pat (fn _ => let val  (Pat as Pat1) = Pat1
 ()
 val  (Ty as Ty1) = Ty1 ()
 in ( TYPEDpat (PP Patleft Tyright, Pat, Ty) )
end)
 in ( LrTable.NT 52, ( result, Pat1left, Ty1right), rest671)
end
|  ( 261, ( ( _, ( MlyValue.Pat Pat2, _, Pat2right)) :: _ :: ( _, ( 
MlyValue.Pat Pat1, Pat1left, _)) :: rest671)) => let val  result = 
MlyValue.Pat (fn _ => let val  Pat1 = Pat1 ()
 val  Pat2 = Pat2 ()
 in ( layeredPat (PP Pat1left Pat2right, Pat1, Pat2) )
end)
 in ( LrTable.NT 52, ( result, Pat1left, Pat2right), rest671)
end
|  ( 262, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: _ ::
 ( _, ( MlyValue.TupleTy TupleTy1, (TupleTyleft as TupleTy1left), _))
 :: rest671)) => let val  result = MlyValue.Ty (fn _ => let val  (
TupleTy as TupleTy1) = TupleTy1 ()
 val  (Ty as Ty1) = Ty1 ()
 in (
 FNty (PP TupleTyleft Tyright,
				(case TupleTy of
				   [t] => t
				 | ts => tuple_type (PP TupleTyleft Tyright) ts),
				NONE,
                                Ty) 
)
end)
 in ( LrTable.NT 46, ( result, TupleTy1left, Ty1right), rest671)
end
|  ( 263, ( ( _, ( MlyValue.Ty Ty1, _, (Tyright as Ty1right))) :: _ ::
 ( _, ( MlyValue.Ident Ident1, Identleft, Identright)) :: _ :: ( _, ( 
MlyValue.TupleTy TupleTy1, (TupleTyleft as TupleTy1left), _)) :: 
rest671)) => let val  result = MlyValue.Ty (fn _ => let val  (TupleTy
 as TupleTy1) = TupleTy1 ()
 val  (Ident as Ident1) = Ident1 ()
 val  (Ty as Ty1) = Ty1 ()
 in (
 FNty (PP TupleTyleft Tyright,
				(case TupleTy of
				   [t] => t
				 | ts => tuple_type (PP TupleTyleft Tyright) ts),
                                SOME(PP Identleft Identright, RegVar.mk_Named Ident),
				Ty) 
)
end)
 in ( LrTable.NT 46, ( result, TupleTy1left, Ty1right), rest671)
end
|  ( 264, ( ( _, ( MlyValue.TupleTy TupleTy1, (TupleTyleft as 
TupleTy1left), (TupleTyright as TupleTy1right))) :: rest671)) => let
 val  result = MlyValue.Ty (fn _ => let val  (TupleTy as TupleTy1) = 
TupleTy1 ()
 in (
 (case TupleTy of
			     [t] => t
			   | ts => tuple_type (PP TupleTyleft TupleTyright) ts) 
)
end)
 in ( LrTable.NT 46, ( result, TupleTy1left, TupleTy1right), rest671)

end
|  ( 265, ( ( _, ( MlyValue.Ty_sans_STAR Ty_sans_STAR1, 
Ty_sans_STAR1left, Ty_sans_STAR1right)) :: rest671)) => let val  
result = MlyValue.TupleTy (fn _ => let val  (Ty_sans_STAR as 
Ty_sans_STAR1) = Ty_sans_STAR1 ()
 in ( [Ty_sans_STAR] )
end)
 in ( LrTable.NT 47, ( result, Ty_sans_STAR1left, Ty_sans_STAR1right),
 rest671)
end
|  ( 266, ( ( _, ( MlyValue.TupleTy TupleTy1, _, TupleTy1right)) :: _
 :: ( _, ( MlyValue.Ty_sans_STAR Ty_sans_STAR1, Ty_sans_STAR1left, _))
 :: rest671)) => let val  result = MlyValue.TupleTy (fn _ => let val 
 (Ty_sans_STAR as Ty_sans_STAR1) = Ty_sans_STAR1 ()
 val  (TupleTy as TupleTy1) = TupleTy1 ()
 in ( Ty_sans_STAR :: TupleTy )
end)
 in ( LrTable.NT 47, ( result, Ty_sans_STAR1left, TupleTy1right), 
rest671)
end
|  ( 267, ( ( _, ( MlyValue.EqIdent EqIdent1, EqIdentleft, (
EqIdentright as EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: (
 _, ( MlyValue.LongTypeIdent LongTypeIdent1, LongTypeIdentleft, 
LongTypeIdentright)) :: _ :: ( _, ( MlyValue.TyComma_seq2 
TyComma_seq21, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) ::
 rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ => let
 val  (TyComma_seq2 as TyComma_seq21) = TyComma_seq21 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 let val ty = CONty (PP LPARENleft LongTypeIdentright,
				              TyComma_seq2, mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft EqIdentright,
                                    ty,
                                    SOME (PP BACKQUOTEleft EqIdentright,
                                          [(PP EqIdentleft EqIdentright,
                                            RegVar.mk_Named EqIdent)]))
                          end 
)
end)
 in ( LrTable.NT 48, ( result, LPAREN1left, EqIdent1right), rest671)

end
|  ( 268, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, EqIdent_seq1left, 
EqIdent_seq1right)) :: ( _, ( _, LBRACKETleft, _)) :: _ :: ( _, ( 
MlyValue.LongTypeIdent LongTypeIdent1, LongTypeIdentleft, 
LongTypeIdentright)) :: _ :: ( _, ( MlyValue.TyComma_seq2 
TyComma_seq21, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) ::
 rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ => let
 val  (TyComma_seq2 as TyComma_seq21) = TyComma_seq21 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 let val ty = CONty (PP LPARENleft LongTypeIdentright,
				              TyComma_seq2, mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft RBRACKETright,
                                    ty,
                                    SOME (PP LBRACKETleft RBRACKETright,
                                          map (fn r => (PP EqIdent_seq1left EqIdent_seq1right,
                                                        RegVar.mk_Named r)) EqIdent_seq1))
                          end 
)
end)
 in ( LrTable.NT 48, ( result, LPAREN1left, RBRACKET1right), rest671)

end
|  ( 269, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, _, (
LongTypeIdentright as LongTypeIdent1right))) :: _ :: ( _, ( 
MlyValue.TyComma_seq2 TyComma_seq21, _, _)) :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.Ty_sans_STAR (fn _ => let val  (TyComma_seq2 as TyComma_seq21
) = TyComma_seq21 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 in (
 CONty (PP LPARENleft LongTypeIdentright,
				 TyComma_seq2, mk_LongTyCon LongTypeIdent) 
)
end)
 in ( LrTable.NT 48, ( result, LPAREN1left, LongTypeIdent1right), 
rest671)
end
|  ( 270, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, _, (
LongTypeIdentright as LongTypeIdent1right))) :: ( _, ( 
MlyValue.Ty_sans_STAR Ty_sans_STAR1, (Ty_sans_STARleft as 
Ty_sans_STAR1left), _)) :: rest671)) => let val  result = 
MlyValue.Ty_sans_STAR (fn _ => let val  (Ty_sans_STAR as Ty_sans_STAR1
) = Ty_sans_STAR1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 in (
 CONty (PP Ty_sans_STARleft LongTypeIdentright,
				 [Ty_sans_STAR], mk_LongTyCon LongTypeIdent) 
)
end)
 in ( LrTable.NT 48, ( result, Ty_sans_STAR1left, LongTypeIdent1right)
, rest671)
end
|  ( 271, ( ( _, ( MlyValue.EqIdent EqIdent1, EqIdentleft, (
EqIdentright as EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: (
 _, ( MlyValue.LongTypeIdent LongTypeIdent1, LongTypeIdentleft, 
LongTypeIdentright)) :: ( _, ( MlyValue.Ty_sans_STAR Ty_sans_STAR1, (
Ty_sans_STARleft as Ty_sans_STAR1left), _)) :: rest671)) => let val  
result = MlyValue.Ty_sans_STAR (fn _ => let val  (Ty_sans_STAR as 
Ty_sans_STAR1) = Ty_sans_STAR1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 let val ty = CONty (PP Ty_sans_STARleft LongTypeIdentright,
				              [Ty_sans_STAR], mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft EqIdentright,
                                    ty,
                                    SOME (PP BACKQUOTEleft EqIdentright,
                                          [(PP EqIdentleft EqIdentright,
                                            RegVar.mk_Named EqIdent)]))
                          end 
)
end)
 in ( LrTable.NT 48, ( result, Ty_sans_STAR1left, EqIdent1right), 
rest671)
end
|  ( 272, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, EqIdent_seq1left, 
EqIdent_seq1right)) :: ( _, ( _, LBRACKETleft, _)) :: _ :: ( _, ( 
MlyValue.LongTypeIdent LongTypeIdent1, LongTypeIdentleft, 
LongTypeIdentright)) :: ( _, ( MlyValue.Ty_sans_STAR Ty_sans_STAR1, (
Ty_sans_STARleft as Ty_sans_STAR1left), _)) :: rest671)) => let val  
result = MlyValue.Ty_sans_STAR (fn _ => let val  (Ty_sans_STAR as 
Ty_sans_STAR1) = Ty_sans_STAR1 ()
 val  (LongTypeIdent as LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 let val ty = CONty (PP Ty_sans_STARleft LongTypeIdentright,
				              [Ty_sans_STAR], mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft RBRACKETright,
                                    ty,
                                    SOME (PP LBRACKETleft RBRACKETright,
                                          map (fn r => (PP EqIdent_seq1left EqIdent_seq1right,
                                                        RegVar.mk_Named r)) EqIdent_seq1))
                          end 
)
end)
 in ( LrTable.NT 48, ( result, Ty_sans_STAR1left, RBRACKET1right), 
rest671)
end
|  ( 273, ( ( _, ( MlyValue.AtomicTy AtomicTy1, AtomicTy1left, 
AtomicTy1right)) :: rest671)) => let val  result = 
MlyValue.Ty_sans_STAR (fn _ => let val  (AtomicTy as AtomicTy1) = 
AtomicTy1 ()
 in ( AtomicTy )
end)
 in ( LrTable.NT 48, ( result, AtomicTy1left, AtomicTy1right), rest671
)
end
|  ( 274, ( ( _, ( MlyValue.Ident Ident2, Ident2left, Ident2right)) ::
 _ :: ( _, ( MlyValue.Ident Ident1, Ident1left, _)) :: _ :: ( _, ( 
MlyValue.AtomicTy AtomicTy1, (AtomicTyleft as AtomicTy1left), _)) :: 
rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ => let val 
 (AtomicTy as AtomicTy1) = AtomicTy1 ()
 val  Ident1 = Ident1 ()
 val  Ident2 = Ident2 ()
 in (
 WITHty (PP AtomicTyleft Ident2right,
                                  AtomicTy,
                                  INCLconstraint(PP Ident1left Ident2right,
                                                 (PP Ident1left Ident2right,
                                                  RegVar.mk_Named Ident1),
                                                 VAReff (PP Ident2left Ident2right,
                                                         RegVar.mk_Named Ident2)))
                        
)
end)
 in ( LrTable.NT 48, ( result, AtomicTy1left, Ident2right), rest671)

end
|  ( 275, ( ( _, ( MlyValue.Ident Ident2, Ident2left, Ident2right)) ::
 ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: _ :: ( _, 
( MlyValue.AtomicTy AtomicTy1, (AtomicTyleft as AtomicTy1left), _)) ::
 rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ => let
 val  (AtomicTy as AtomicTy1) = AtomicTy1 ()
 val  Ident1 = Ident1 ()
 val  Ident2 = Ident2 ()
 in (
 let fun toProp (i, s) =
                           case s of
                               "nomut" => NOMUTprop i
                             | "noput" => NOPUTprop i
                             | "noexn" => NOEXNprop i
                             | _ => raise LEXICAL_ERROR (Ident1left, "expecting nomut, noput, or noexn")
                    in
                        WITHty (PP AtomicTyleft Ident2right,
                                AtomicTy,
                                PROPconstraint(PP Ident1left Ident2right,
                                               toProp (PP Ident1left Ident1right,
                                                       Ident1),
                                               VAReff (PP Ident2left Ident2right,
                                                       RegVar.mk_Named Ident2)
                                              )
                               )
                    end 
)
end)
 in ( LrTable.NT 48, ( result, AtomicTy1left, Ident2right), rest671)

end
|  ( 276, ( ( _, ( MlyValue.Ident Ident2, Ident2left, Ident2right)) ::
 _ :: ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: _ :: 
( _, ( MlyValue.AtomicTy AtomicTy1, (AtomicTyleft as AtomicTy1left), _
)) :: rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ =>
 let val  (AtomicTy as AtomicTy1) = AtomicTy1 ()
 val  Ident1 = Ident1 ()
 val  Ident2 = Ident2 ()
 in (
 let
                    in WITHty (PP AtomicTyleft Ident2right,
                               AtomicTy,
                               DISJOINTconstraint(PP Ident1left Ident2right,
                                                  VAReff (PP Ident1left Ident1right,
                                                          RegVar.mk_Named Ident1),
                                                  VAReff (PP Ident2left Ident2right,
                                                          RegVar.mk_Named Ident2),
                                                  false
                                                 )
                             )
                  end 
)
end)
 in ( LrTable.NT 48, ( result, AtomicTy1left, Ident2right), rest671)

end
|  ( 277, ( ( _, ( MlyValue.Ident Ident2, Ident2left, Ident2right)) ::
 _ :: ( _, ( MlyValue.Ident Ident1, Ident1left, Ident1right)) :: _ :: 
( _, ( MlyValue.AtomicTy AtomicTy1, (AtomicTyleft as AtomicTy1left), _
)) :: rest671)) => let val  result = MlyValue.Ty_sans_STAR (fn _ =>
 let val  (AtomicTy as AtomicTy1) = AtomicTy1 ()
 val  Ident1 = Ident1 ()
 val  Ident2 = Ident2 ()
 in (
 let
                    in WITHty (PP AtomicTyleft Ident2right,
                               AtomicTy,
                               DISJOINTconstraint(PP Ident1left Ident2right,
                                                  VAReff (PP Ident1left Ident1right,
                                                          RegVar.mk_Named Ident1),
                                                  VAReff (PP Ident2left Ident2right,
                                                          RegVar.mk_Named Ident2),
                                                  true
                                                 )
                             )
                    end 
)
end)
 in ( LrTable.NT 48, ( result, AtomicTy1left, Ident2right), rest671)

end
|  ( 278, ( ( _, ( MlyValue.TyComma_seq2 TyComma_seq21, _, 
TyComma_seq21right)) :: _ :: ( _, ( MlyValue.Ty Ty1, Ty1left, _)) :: 
rest671)) => let val  result = MlyValue.TyComma_seq2 (fn _ => let val 
 (Ty as Ty1) = Ty1 ()
 val  (TyComma_seq2 as TyComma_seq21) = TyComma_seq21 ()
 in ( Ty :: TyComma_seq2 )
end)
 in ( LrTable.NT 104, ( result, Ty1left, TyComma_seq21right), rest671)

end
|  ( 279, ( ( _, ( MlyValue.Ty Ty2, _, Ty2right)) :: _ :: ( _, ( 
MlyValue.Ty Ty1, Ty1left, _)) :: rest671)) => let val  result = 
MlyValue.TyComma_seq2 (fn _ => let val  Ty1 = Ty1 ()
 val  Ty2 = Ty2 ()
 in ( [Ty1, Ty2] )
end)
 in ( LrTable.NT 104, ( result, Ty1left, Ty2right), rest671)
end
|  ( 280, ( ( _, ( MlyValue.EqIdent EqIdent1, EqIdentleft, (
EqIdentright as EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: (
 _, ( MlyValue.LongTypeIdent LongTypeIdent1, (LongTypeIdentleft as 
LongTypeIdent1left), LongTypeIdentright)) :: rest671)) => let val  
result = MlyValue.AtomicTy (fn _ => let val  (LongTypeIdent as 
LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 let val ty = CONty (PP LongTypeIdentleft LongTypeIdentright,
				              [], mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft EqIdentright,
                                    ty,
                                    SOME (PP BACKQUOTEleft EqIdentright,
                                          [(PP EqIdentleft EqIdentright,
                                            RegVar.mk_Named EqIdent)]))
                          end
)
end)
 in ( LrTable.NT 49, ( result, LongTypeIdent1left, EqIdent1right), 
rest671)
end
|  ( 281, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, EqIdent_seq1left, 
EqIdent_seq1right)) :: ( _, ( _, LBRACKETleft, _)) :: _ :: ( _, ( 
MlyValue.LongTypeIdent LongTypeIdent1, (LongTypeIdentleft as 
LongTypeIdent1left), LongTypeIdentright)) :: rest671)) => let val  
result = MlyValue.AtomicTy (fn _ => let val  (LongTypeIdent as 
LongTypeIdent1) = LongTypeIdent1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 let val ty = CONty (PP LongTypeIdentleft LongTypeIdentright,
				              [], mk_LongTyCon LongTypeIdent)
                          in PARty (PP LongTypeIdentleft RBRACKETright,
                                    ty,
                                    SOME (PP LBRACKETleft RBRACKETright,
                                          map (fn r => (PP EqIdent_seq1left EqIdent_seq1right,
                                                        RegVar.mk_Named r)) EqIdent_seq1))
                          end
)
end)
 in ( LrTable.NT 49, ( result, LongTypeIdent1left, RBRACKET1right), 
rest671)
end
|  ( 282, ( ( _, ( MlyValue.LongTypeIdent LongTypeIdent1, (
LongTypeIdentleft as LongTypeIdent1left), (LongTypeIdentright as 
LongTypeIdent1right))) :: rest671)) => let val  result = 
MlyValue.AtomicTy (fn _ => let val  (LongTypeIdent as LongTypeIdent1)
 = LongTypeIdent1 ()
 in (
 CONty (PP LongTypeIdentleft LongTypeIdentright,
				 [], mk_LongTyCon LongTypeIdent) 
)
end)
 in ( LrTable.NT 49, ( result, LongTypeIdent1left, LongTypeIdent1right
), rest671)
end
|  ( 283, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.AtomicTy (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in ( TYVARty(PP TYVARleft TYVARright, mk_TyVar TYVAR) )
end)
 in ( LrTable.NT 49, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 284, ( ( _, ( MlyValue.EqIdent EqIdent1, _, (EqIdentright as 
EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( _, _, 
RBRACEright)) :: ( _, ( MlyValue.TyRow_opt TyRow_opt1, _, _)) :: ( _, 
( _, (LBRACEleft as LBRACE1left), _)) :: rest671)) => let val  result
 = MlyValue.AtomicTy (fn _ => let val  (TyRow_opt as TyRow_opt1) = 
TyRow_opt1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 RECORDty (PP LBRACEleft RBRACEright,
                                    TyRow_opt,
                                    SOME (PP BACKQUOTEleft EqIdentright, RegVar.mk_Named EqIdent)) 
)
end)
 in ( LrTable.NT 49, ( result, LBRACE1left, EqIdent1right), rest671)

end
|  ( 285, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.TyRow_opt TyRow_opt1, _, _)) :: ( _, ( _, (LBRACEleft as 
LBRACE1left), _)) :: rest671)) => let val  result = MlyValue.AtomicTy
 (fn _ => let val  (TyRow_opt as TyRow_opt1) = TyRow_opt1 ()
 in ( RECORDty (PP LBRACEleft RBRACEright, TyRow_opt, NONE) )
end)
 in ( LrTable.NT 49, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 286, ( ( _, ( MlyValue.EqIdent EqIdent1, EqIdentleft, (
EqIdentright as EqIdent1right))) :: ( _, ( _, BACKQUOTEleft, _)) :: (
 _, ( _, _, RPARENright)) :: ( _, ( MlyValue.Ty Ty1, _, _)) :: ( _, (
 _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result =
 MlyValue.AtomicTy (fn _ => let val  (Ty as Ty1) = Ty1 ()
 val  (EqIdent as EqIdent1) = EqIdent1 ()
 in (
 PARty (PP LPARENleft RPARENright,
                                 Ty,
                                 SOME (PP BACKQUOTEleft EqIdentright,
                                       [(PP EqIdentleft EqIdentright,
                                         RegVar.mk_Named EqIdent)])) 
)
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, EqIdent1right), rest671)

end
|  ( 287, ( ( _, ( _, _, (RBRACKETright as RBRACKET1right))) :: ( _, (
 MlyValue.EqIdent_seq1 EqIdent_seq11, EqIdent_seq1left, 
EqIdent_seq1right)) :: _ :: ( _, ( _, BACKQUOTEleft, _)) :: ( _, ( _,
 _, RPARENright)) :: ( _, ( MlyValue.Ty Ty1, _, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.AtomicTy (fn _ => let val  (Ty as Ty1) = Ty1 ()
 val  (EqIdent_seq1 as EqIdent_seq11) = EqIdent_seq11 ()
 in (
 PARty (PP LPARENleft RPARENright,
                                 Ty,
                                 SOME (PP BACKQUOTEleft RBRACKETright,
                                       map (fn s => (PP EqIdent_seq1left EqIdent_seq1right,
                                                     RegVar.mk_Named s)) EqIdent_seq1))
)
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RBRACKET1right), rest671)

end
|  ( 288, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.Ty Ty1, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.AtomicTy (fn _ => let val 
 (Ty as Ty1) = Ty1 ()
 in ( PARty (PP LPARENleft RPARENright, Ty, NONE) )
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 289, ( ( _, ( MlyValue.TyRow TyRow1, TyRow1left, TyRow1right)) ::
 rest671)) => let val  result = MlyValue.TyRow_opt (fn _ => let val  (
TyRow as TyRow1) = TyRow1 ()
 in ( SOME TyRow )
end)
 in ( LrTable.NT 87, ( result, TyRow1left, TyRow1right), rest671)
end
|  ( 290, ( rest671)) => let val  result = MlyValue.TyRow_opt (fn _ =>
 ( NONE ))
 in ( LrTable.NT 87, ( result, defaultPos, defaultPos), rest671)
end
|  ( 291, ( ( _, ( MlyValue.CommaTyRow_opt CommaTyRow_opt1, _, 
CommaTyRow_opt1right)) :: ( _, ( MlyValue.Ty Ty1, _, _)) :: _ :: ( _, 
( MlyValue.Label Label1, (Labelleft as Label1left), _)) :: rest671))
 => let val  result = MlyValue.TyRow (fn _ => let val  (Label as 
Label1) = Label1 ()
 val  (Ty as Ty1) = Ty1 ()
 val  (CommaTyRow_opt as CommaTyRow_opt1) = CommaTyRow_opt1 ()
 in (
 TYROW (PP Labelleft
				   (rightmost get_info_ty Ty
				              get_info_tyrow CommaTyRow_opt),
				 Label, Ty, CommaTyRow_opt) 
)
end)
 in ( LrTable.NT 45, ( result, Label1left, CommaTyRow_opt1right), 
rest671)
end
|  ( 292, ( ( _, ( MlyValue.TyRow TyRow1, _, TyRow1right)) :: ( _, ( _
, COMMA1left, _)) :: rest671)) => let val  result = 
MlyValue.CommaTyRow_opt (fn _ => let val  (TyRow as TyRow1) = TyRow1
 ()
 in ( SOME TyRow )
end)
 in ( LrTable.NT 88, ( result, COMMA1left, TyRow1right), rest671)
end
|  ( 293, ( rest671)) => let val  result = MlyValue.CommaTyRow_opt (fn
 _ => ( NONE ))
 in ( LrTable.NT 88, ( result, defaultPos, defaultPos), rest671)
end
|  ( 294, ( ( _, ( MlyValue.DECPOSINTEGER DECPOSINTEGER1, (
DECPOSINTEGERleft as DECPOSINTEGER1left), DECPOSINTEGER1right)) :: 
rest671)) => let val  result = MlyValue.Integer (fn _ => let val  (
DECPOSINTEGER as DECPOSINTEGER1) = DECPOSINTEGER1 ()
 in (
 raise_lexical_error_if_none
			    DECPOSINTEGERleft DECPOSINTEGER )

end)
 in ( LrTable.NT 125, ( result, DECPOSINTEGER1left, 
DECPOSINTEGER1right), rest671)
end
|  ( 295, ( ( _, ( MlyValue.DECNEGINTEGER DECNEGINTEGER1, (
DECNEGINTEGERleft as DECNEGINTEGER1left), DECNEGINTEGER1right)) :: 
rest671)) => let val  result = MlyValue.Integer (fn _ => let val  (
DECNEGINTEGER as DECNEGINTEGER1) = DECNEGINTEGER1 ()
 in (
 raise_lexical_error_if_none
			    DECNEGINTEGERleft DECNEGINTEGER )

end)
 in ( LrTable.NT 125, ( result, DECNEGINTEGER1left, 
DECNEGINTEGER1right), rest671)
end
|  ( 296, ( ( _, ( MlyValue.HEXINTEGER HEXINTEGER1, (HEXINTEGERleft
 as HEXINTEGER1left), HEXINTEGER1right)) :: rest671)) => let val  
result = MlyValue.Integer (fn _ => let val  (HEXINTEGER as HEXINTEGER1
) = HEXINTEGER1 ()
 in ( raise_lexical_error_if_none
			    HEXINTEGERleft HEXINTEGER )

end)
 in ( LrTable.NT 125, ( result, HEXINTEGER1left, HEXINTEGER1right), 
rest671)
end
|  ( 297, ( ( _, ( MlyValue.DIGIT DIGIT1, DIGIT1left, DIGIT1right)) ::
 rest671)) => let val  result = MlyValue.Integer (fn _ => let val  (
DIGIT as DIGIT1) = DIGIT1 ()
 in ( IntInf.fromInt DIGIT )
end)
 in ( LrTable.NT 125, ( result, DIGIT1left, DIGIT1right), rest671)
end
|  ( 298, ( ( _, ( MlyValue.STRING STRING1, STRINGleft, STRING1right))
 :: ( _, ( _, HASH1left, _)) :: rest671)) => let val  result = 
MlyValue.Char (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (
 case explode STRING
                            of [c] => ord c
                             | _ => raise LEXICAL_ERROR (STRINGleft, "string must have length 1") 
)
end)
 in ( LrTable.NT 126, ( result, HASH1left, STRING1right), rest671)
end
|  ( 299, ( ( _, ( MlyValue.Integer Integer1, Integer1left, 
Integer1right)) :: rest671)) => let val  result = MlyValue.SCon (fn _
 => let val  (Integer as Integer1) = Integer1 ()
 in ( mk_IntSCon Integer )
end)
 in ( LrTable.NT 51, ( result, Integer1left, Integer1right), rest671)

end
|  ( 300, ( ( _, ( MlyValue.WORD WORD1, (WORDleft as WORD1left), 
WORD1right)) :: rest671)) => let val  result = MlyValue.SCon (fn _ =>
 let val  (WORD as WORD1) = WORD1 ()
 in ( mk_WordSCon (raise_lexical_error_if_none WORDleft WORD) )
end)
 in ( LrTable.NT 51, ( result, WORD1left, WORD1right), rest671)
end
|  ( 301, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right)
) :: rest671)) => let val  result = MlyValue.SCon (fn _ => let val  (
STRING as STRING1) = STRING1 ()
 in ( mk_StringSCon STRING )
end)
 in ( LrTable.NT 51, ( result, STRING1left, STRING1right), rest671)

end
|  ( 302, ( ( _, ( MlyValue.Char Char1, Char1left, Char1right)) :: 
rest671)) => let val  result = MlyValue.SCon (fn _ => let val  (Char
 as Char1) = Char1 ()
 in ( mk_CharSCon Char )
end)
 in ( LrTable.NT 51, ( result, Char1left, Char1right), rest671)
end
|  ( 303, ( ( _, ( MlyValue.REAL REAL1, (REALleft as REAL1left), 
REAL1right)) :: rest671)) => let val  result = MlyValue.SCon (fn _ =>
 let val  (REAL as REAL1) = REAL1 ()
 in ( mk_RealSCon (raise_lexical_error_if_none REALleft REAL) )
end)
 in ( LrTable.NT 51, ( result, REAL1left, REAL1right), rest671)
end
|  ( 304, ( ( _, ( MlyValue.TyVarSeq1 TyVarSeq11, TyVarSeq11left, 
TyVarSeq11right)) :: rest671)) => let val  result = MlyValue.TyVarSeq
 (fn _ => let val  (TyVarSeq1 as TyVarSeq11) = TyVarSeq11 ()
 in ( TyVarSeq1 )
end)
 in ( LrTable.NT 50, ( result, TyVarSeq11left, TyVarSeq11right), 
rest671)
end
|  ( 305, ( rest671)) => let val  result = MlyValue.TyVarSeq (fn _ =>
 ( [] ))
 in ( LrTable.NT 50, ( result, defaultPos, defaultPos), rest671)
end
|  ( 306, ( ( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, TYVAR1right)) ::
 rest671)) => let val  result = MlyValue.TyVarSeq1 (fn _ => let val  (
TYVAR as TYVAR1) = TYVAR1 ()
 in ( [mk_TyVar TYVAR] )
end)
 in ( LrTable.NT 102, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 307, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.TyVarComma_seq1 TyVarComma_seq11, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.TyVarSeq1
 (fn _ => let val  (TyVarComma_seq1 as TyVarComma_seq11) = 
TyVarComma_seq11 ()
 in ( TyVarComma_seq1 )
end)
 in ( LrTable.NT 102, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 308, ( ( _, ( MlyValue.TyVarComma_seq1 TyVarComma_seq11, _, 
TyVarComma_seq11right)) :: _ :: ( _, ( MlyValue.TYVAR TYVAR1, 
TYVAR1left, _)) :: rest671)) => let val  result = 
MlyValue.TyVarComma_seq1 (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1
 ()
 val  (TyVarComma_seq1 as TyVarComma_seq11) = TyVarComma_seq11 ()
 in ( mk_TyVar TYVAR :: TyVarComma_seq1 )
end)
 in ( LrTable.NT 103, ( result, TYVAR1left, TyVarComma_seq11right), 
rest671)
end
|  ( 309, ( ( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, TYVAR1right)) ::
 rest671)) => let val  result = MlyValue.TyVarComma_seq1 (fn _ => let
 val  (TYVAR as TYVAR1) = TYVAR1 ()
 in ( [mk_TyVar TYVAR] )
end)
 in ( LrTable.NT 103, ( result, TYVAR1left, TYVAR1right), rest671)
end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.TopDec x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Topdec_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun INCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun SHARING (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun SIG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun SIGNATURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun QUAL_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.QUAL_ID (fn () => i),p1,p2))
fun QUAL_STAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.QUAL_STAR (fn () => i),p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun COLONGREATER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun ABSTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun ANDALSO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun AS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun CASE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun DO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCEPTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun FN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun HANDLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun IF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun IN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIXR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun LOCAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun NONFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun ORELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun RAISE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun REC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun TYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun LPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun DOTDOTDOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun UNDERBAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun DARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun HASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun HASHHASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun DECPOSINTEGER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.DECPOSINTEGER (fn () => i),p1,p2))
fun DECNEGINTEGER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.DECNEGINTEGER (fn () => i),p1,p2))
fun HEXINTEGER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.HEXINTEGER (fn () => i),p1,p2))
fun DIGIT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.DIGIT (fn () => i),p1,p2))
fun WORD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.WORD (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun BEGINQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun ENDQ (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.ENDQ (fn () => i),p1,p2))
fun OBJL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.OBJL (fn () => i),p1,p2))
fun AQID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.AQID (fn () => i),p1,p2))
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
fun TYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.TYVAR (fn () => i),p1,p2))
fun BACKQUOTE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun REGION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.VOID,p1,p2))
end
end
